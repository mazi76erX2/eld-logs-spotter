"""
Django settings for eld_logs project.

Generated by 'django-admin startproject' using Django 6.0.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/6.0/ref/settings/
"""

from pathlib import Path

from decouple import Csv, config

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/6.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY: str = config(
    "SECRET_KEY",
    default="django-insecure-6*^%+(^j&eyng6v-(=7xeabs)%cl7+z9((o+6med7w-v&4cms7",
)

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG: bool = config("DEBUG", default=True, cast=bool)

ALLOWED_HOSTS: list[str] = config(
    "ALLOWED_HOSTS", default="localhost,127.0.0.1", cast=Csv()
)


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # Third party apps
    "rest_framework",
    "corsheaders",
    "drf_spectacular",
    "channels",
    "django_celery_results",
    # Local apps
    "route_calculator",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "eld_logs.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "eld_logs.wsgi.application"
ASGI_APPLICATION = "eld_logs.asgi.application"

# Database
# https://docs.djangoproject.com/en/6.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}

https://github.com/mazi76erX2/eld-logs-spotter

can you see this code base? If so evaluate the backend and make improvements if needed and add postgres support.

Also I need the map generator to be handled as a task because it takes long but there needs to be a way to communicate this to the frontend


Thought Process
expand
Unable to Access External URLs
I cannot directly access GitHub repositories or any external URLs. I can only see content that's shared directly in our conversation.

How You Can Share the Code
Please share the relevant code files by:

Copy-pasting the code directly into the chat
Describing the project structure and sharing key files
What I'll Need to Help You
To evaluate the backend, add PostgreSQL support, and implement async task handling, please share:

Essential Files:
text
├── Backend files (e.g., main.py, app.py, routes/views)
├── Models/schemas
├── Database configuration
├── Requirements.txt / pyproject.toml
├── Map generator logic
└── Any existing task/queue setup
What I Can Help With Once You Share:
Task	Description
Backend Evaluation	Code quality, structure, best practices, security
PostgreSQL Support	SQLAlchemy/async setup, migrations, connection pooling
Async Task Queue	Celery, RQ, or arq for background map generation
Frontend Communication	WebSockets, SSE, or polling for task status updates
Please paste the main backend files and I'll provide:

A detailed code review
Improved/refactored code
PostgreSQL integration
Background task implementation with progress tracking
Claude Opus 4.5
================================================
FILE: README.md
eld-logs-spotter
An App that takes inputs of start and finish location both within the USA written in Django and NextJS and creates an ELD log

================================================
FILE: eld_logs/README.md
[Empty file]

================================================
FILE: eld_logs/manage.py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys

from decouple import config

DJANGO_SETTINGS_MODULE: str = config(
"DJANGO_SETTINGS_MODULE",
default="eld_logs.settings.local",
)

def main():
"""Run administrative tasks."""
os.environ.setdefault("DJANGO_SETTINGS_MODULE", DJANGO_SETTINGS_MODULE)
try:
from django.core.management import execute_from_command_line
except ImportError as exc:
raise ImportError(
"Couldn't import Django. Are you sure it's installed and "
"available on your PYTHONPATH environment variable? Did you "
"forget to activate a virtual environment?"
) from exc
execute_from_command_line(sys.argv)

if name == "main":
main()

================================================
FILE: eld_logs/pyproject.toml
[project]
name = "eld-logs"
version = "0.1.0"
description = "ELD logs and route planning API"
readme = "README.md"
requires-python = ">=3.14"

dependencies = [
"Django==6.0.0",
"djangorestframework==3.16.1",
"django-cors-headers==4.9.0",
"celery==5.6.0",
"redis==7.1.0",
"openrouteservice==2.3.3",
"Pillow==12.0.0",
"python-dotenv==1.2.1",
"requests==2.32.5",
"python-decouple==3.8",
"drf-spectacular==0.29.0",
"staticmap==0.5.7",
]

[dependency-groups]
dev = ["pytest"]

[tool.uv]
compile-bytecode = true
resolution = "highest"

================================================
FILE: eld_logs/requirements.txt
Django==6.0.0
djangorestframework==3.16.1
django-cors-headers==4.9.0
celery==5.6.0
redis==7.1.0
openrouteservice==2.3.3
Pillow==12.0.0
python-dotenv==1.2.1
requests==2.32.5
python-decouple==3.8

================================================
FILE: eld_logs/.env.example
Django Settings
SECRET_KEY=django-insecure-change-this-in-production-abc123xyz789
DEBUG=True
ALLOWED_HOSTS=localhost,127.0.0.1,0.0.0.0
DJANGO_SETTINGS_MODULE=eld_logs.settings.local

Database - PostgreSQL
DATABASE_NAME=eld_db
DATABASE_USERNAME=eld_user
DATABASE_PASSWORD=eld_password_123
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_URL=postgresql://
D
A
T
A
B
A
S
E
U
S
E
R
N
A
M
E
:
DATABASE 
U
​
 SERNAME:{DATABASE_PASSWORD}@
D
A
T
A
B
A
S
E
H
O
S
T
:
DATABASE 
H
​
 OST:{DATABASE_PORT}/${DATABASE_NAME}

Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_URL=redis://
R
E
D
I
S
H
O
S
T
:
REDIS 
H
​
 OST:{REDIS_PORT}/0

Celery
CELERY_BROKER_URL=
R
E
D
I
S
U
R
L
C
E
L
E
R
Y
R
E
S
U
L
T
B
A
C
K
E
N
D
=
REDIS 
U
​
 RLCELERY 
R
​
 ESULT 
B
​
 ACKEND={REDIS_URL}

OpenRouteService API
OPENROUTESERVICE_API_KEY=your_openrouteservice_api_key_here

CORS Settings
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173,http://127.0.0.1:3000

Application
PYTHONPATH=.
APP_DIR=.

================================================
FILE: eld_logs/.python-version
3.14

================================================
FILE: eld_logs/eld_logs/init.py
from .celery import app as celery_app

all = ("celery_app",)

================================================
FILE: eld_logs/eld_logs/asgi.py
"""
ASGI config for eld_logs project.

It exposes the ASGI callable as a module-level variable named application.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

from decouple import config

DJANGO_SETTINGS_MODULE: str = config(
"DJANGO_SETTINGS_MODULE",
default="eld_logs.settings.local",
)

os.environ.setdefault("DJANGO_SETTINGS_MODULE", DJANGO_SETTINGS_MODULE)

application = get_asgi_application()

================================================
FILE: eld_logs/eld_logs/celery.py
import os
from celery import Celery

from decouple import config

DJANGO_SETTINGS_MODULE: str = config(
"DJANGO_SETTINGS_MODULE",
default="eld_logs.settings.local",
)

Set default Django settings module
os.environ.setdefault("DJANGO_SETTINGS_MODULE", DJANGO_SETTINGS_MODULE)

app = Celery("eld_logs")

Load config from Django settings, using CELERY_ prefix
app.config_from_object("django.conf:settings", namespace="CELERY")

Auto-discover tasks in all installed apps
app.autodiscover_tasks()

@app.task(bind=True, ignore_result=True)
def debug_task(self):
print(f"Request: {self.request!r}")

================================================
FILE: eld_logs/eld_logs/urls.py
"""
URL configuration for eld_logs project.

The urlpatterns list routes URLs to views. For more information please see:
https://docs.djangoproject.com/en/6.0/topics/http/urls/
Examples:
Function views
1. Add an import: from my_app import views
2. Add a URL to urlpatterns: path('', views.home, name='home')
Class-based views
1. Add an import: from other_app.views import Home
2. Add a URL to urlpatterns: path('', Home.as_view(), name='home')
Including another URLconf
1. Import the include() function: from django.urls import include, path
2. Add a URL to urlpatterns: path('blog/', include('blog.urls'))
"""

from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import URLPattern, include, path
from drf_spectacular.views import (SpectacularAPIView, SpectacularRedocView,
SpectacularSwaggerView)
from rest_framework.routers import DefaultRouter
from route_calculator.views import TripCalculationViewSet

router = DefaultRouter()
router.register(r"trips", TripCalculationViewSet, basename="trip")

urlpatterns: list[URLPattern] = [
path("admin/", admin.site.urls),
path("api/", include(router.urls)),
path("api/schema/", SpectacularAPIView.as_view(), name="schema"),
path(
"api/docs/",
SpectacularSwaggerView.as_view(url_name="schema"),
name="swagger-ui",
),
path(
"api/redoc/",
SpectacularRedocView.as_view(url_name="schema"),
name="redoc",
),
]

if settings.DEBUG:
urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

================================================
FILE: eld_logs/eld_logs/wsgi.py
"""
WSGI config for eld_logs project.

It exposes the WSGI callable as a module-level variable named application.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

from decouple import config

DJANGO_SETTINGS_MODULE: str = config(
"DJANGO_SETTINGS_MODULE",
default="eld_logs.settings.local",
)

os.environ.setdefault("DJANGO_SETTINGS_MODULE", DJANGO_SETTINGS_MODULE)

application = get_wsgi_application()

================================================
FILE: eld_logs/eld_logs/settings/base.py
"""
Django settings for eld_logs project.

Generated by 'django-admin startproject' using Django 6.0.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/6.0/ref/settings/
"""

from pathlib import Path

from decouple import Csv, config

Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(file).resolve().parent.parent

Quick-start development settings - unsuitable for production
See https://docs.djangoproject.com/en/6.0/howto/deployment/checklist/
SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY: str = config(
"SECRET_KEY",
default="django-insecure-6*^%+(^j&eyng6v-(=7xeabs)%cl7+z9((o+6med7w-v&4cms7",
)

SECURITY WARNING: don't run with debug turned on in production!
DEBUG: bool = config("DEBUG", default=True, cast=bool)

ALLOWED_HOSTS: list[str] = config(
"ALLOWED_HOSTS", default="localhost,127.0.0.1", cast=Csv()
)

Application definition
INSTALLED_APPS = [
"django.contrib.admin",
"django.contrib.auth",
"django.contrib.contenttypes",
"django.contrib.sessions",
"django.contrib.messages",
"django.contrib.staticfiles",
# Third party apps
"rest_framework",
"corsheaders",
"drf_spectacular",
# Local apps
"route_calculator",
]

MIDDLEWARE = [
"corsheaders.middleware.CorsMiddleware",
"django.middleware.security.SecurityMiddleware",
"django.contrib.sessions.middleware.SessionMiddleware",
"django.middleware.common.CommonMiddleware",
"django.middleware.csrf.CsrfViewMiddleware",
"django.contrib.auth.middleware.AuthenticationMiddleware",
"django.contrib.messages.middleware.MessageMiddleware",
"django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "eld_logs.urls"

TEMPLATES = [
{
"BACKEND": "django.template.backends.django.DjangoTemplates",
"DIRS": [],
"APP_DIRS": True,
"OPTIONS": {
"context_processors": [
"django.template.context_processors.request",
"django.contrib.auth.context_processors.auth",
"django.contrib.messages.context_processors.messages",
],
},
},
]

WSGI_APPLICATION = "eld_logs.wsgi.application"

Database
https://docs.djangoproject.com/en/6.0/ref/settings/#databases
DATABASES = {
"default": {
"ENGINE": "django.db.backends.sqlite3",
"NAME": BASE_DIR / "db.sqlite3",
}
}

Password validation
https://docs.djangoproject.com/en/6.0/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
{
"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
},
{
"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
},
{
"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
},
{
"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
},
]

Internationalization
https://docs.djangoproject.com/en/6.0/topics/i18n/
LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True

Static files (CSS, JavaScript, Images)
https://docs.djangoproject.com/en/6.0/howto/static-files/
STATIC_URL: str = "static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [
BASE_DIR / "static",
]

Media files
MEDIA_URL: str = "media/"
MEDIA_ROOT = BASE_DIR / "media"

Default primary key field type
DEFAULT_AUTO_FIELD: str = "django.db.models.BigAutoField"

REST Framework
REST_FRAMEWORK = {
"DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
"PAGE_SIZE": 100,
"DEFAULT_RENDERER_CLASSES": [
"rest_framework.renderers.JSONRenderer",
"rest_framework.renderers.BrowsableAPIRenderer",
],
"DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}

CORS Settings
CORS_ALLOWED_ORIGINS: list[str] = config(
"CORS_ALLOWED_ORIGINS",
default="http://localhost:3000,http://localhost:5173",
cast=Csv(),
)
CORS_ALLOW_CREDENTIALS: bool = True

Celery Configuration
CELERY_BROKER_URL: str = config("REDIS_URL", default="redis://localhost:6379/0")
CELERY_RESULT_BACKEND: str = config("REDIS_URL", default="redis://localhost:6379/0")
CELERY_ACCEPT_CONTENT: list[str] = ["json"]
CELERY_TASK_SERIALIZER: str = "json"
CELERY_RESULT_SERIALIZER: str = "json"
CELERY_TIMEZONE: str = "UTC"
CELERY_TASK_TRACK_STARTED: bool = True
CELERY_TASK_TIME_LIMIT: int = 30 * 60 # 30 minutes

OpenRouteService API Key
OPENROUTESERVICE_API_KEY: str = config("OPENROUTESERVICE_API_KEY", default="")

DRF Spectacular Settings
SPECTACULAR_SETTINGS = {
"TITLE": "ELD Logs API",
"DESCRIPTION": "API for route calculation, FMCSA HOS compliance, ELD logs, and route maps.",
"VERSION": "1.0.0",
"SERVE_INCLUDE_SCHEMA": False,
"COMPONENT_SPLIT_REQUEST": True,
"SCHEMA_PATH_PREFIX": "/api",
}

TEMPLATE_FILENAME = "blank-paper-log.png"

================================================
FILE: eld_logs/eld_logs/settings/local.py
from .base import *

from decouple import Csv, config

ALLOWED_HOSTS: list[str] = config(
"ALLOWED_HOSTS", default="localhost,127.0.0.1", cast=Csv()
)

define which origins are allowed
CORS_ALLOWED_ORIGINS = ["http://localhost:3000", "http://127.0.0.1:3000"]

INSTALLED_APPS += [
"debug_toolbar",
]
MIDDLEWARE += [
"debug_toolbar.middleware.DebugToolbarMiddleware",
]
INTERNAL_IPS = [
# ...
"127.0.0.1",
# ...
]

================================================
FILE: eld_logs/eld_logs/settings/prod.py
import os

from .base import *

from decouple import Csv, config

DEBUG = config("DEBUG", default=False, cast=bool)

Make sure ALLOWED_HOSTS is always set properly
ALLOWED_HOSTS: list[str] = config(
"ALLOWED_HOSTS", default="localhost,127.0.0.1", cast=Csv()
)

For admin static files
STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"

Add your actual domain(s) here
CSRF_TRUSTED_ORIGINS = config(
"CSRF_TRUSTED_ORIGINS",
default="http://localhost:1337,http://127.0.0.1:1337",
cast=Csv(),
)

================================================
FILE: eld_logs/route_calculator/init.py
[Empty file]

================================================
FILE: eld_logs/route_calculator/admin.py
from django.contrib import admin
from django.db.models import QuerySet
from django.http import HttpRequest

from .models import TripCalculation

@admin.register(TripCalculation)
class TripCalculationAdmin(admin.ModelAdmin):
"""Admin interface for TripCalculation model."""

text
list_display: list[str] = [
    "id",
    "current_location",
    "pickup_location",
    "dropoff_location",
    "status",
    "total_distance",
    "total_driving_time",
    "created_at",
]

list_filter: list[str] = [
    "status",
    "created_at",
]

search_fields: list[str] = [
    "current_location",
    "pickup_location",
    "dropoff_location",
]

readonly_fields: list[str] = [
    "created_at",
    "updated_at",
    "total_distance",
    "total_driving_time",
    "total_trip_time",
    "route_data",
    "logs_data",
    "coordinates",
]

fieldsets: list[tuple] = [
    (
        "Trip Information",
        {
            "fields": [
                "current_location",
                "pickup_location",
                "dropoff_location",
                "current_cycle_used",
            ]
        },
    ),
    (
        "Results",
        {
            "fields": [
                "total_distance",
                "total_driving_time",
                "total_trip_time",
                "route_data",
                "logs_data",
                "coordinates",
            ]
        },
    ),
    (
        "Status",
        {
            "fields": [
                "status",
                "error_message",
            ]
        },
    ),
    (
        "Timestamps",
        {
            "fields": [
                "created_at",
                "updated_at",
            ]
        },
    ),
]

def get_queryset(self, request: HttpRequest) -> QuerySet:
    """Optimize queryset."""
    return super().get_queryset(request).select_related()
================================================
FILE: eld_logs/route_calculator/apps.py
from django.apps import AppConfig

class RouteCalculatorConfig(AppConfig):
name = "route_calculator"

================================================
FILE: eld_logs/route_calculator/models.py
from typing import Any

from django.db import models

class TripCalculation(models.Model):
"""Model to store trip calculation data and results."""

text
class JobStatus(models.TextChoices):
    """Job status choices."""

    PENDING = "pending", "Pending"
    PROCESSING = "processing", "Processing"
    COMPLETED = "completed", "Completed"
    FAILED = "failed", "Failed"

current_location = models.CharField(max_length=255)
pickup_location = models.CharField(max_length=255)
dropoff_location = models.CharField(max_length=255)
current_cycle_used = models.FloatField()
total_distance = models.FloatField(null=True, blank=True)
total_driving_time = models.FloatField(null=True, blank=True)
total_trip_time = models.FloatField(null=True, blank=True)
route_data = models.JSONField(null=True, blank=True)
logs_data = models.JSONField(null=True, blank=True)
coordinates = models.JSONField(null=True, blank=True)
status = models.CharField(
    max_length=20, choices=JobStatus.choices, default=JobStatus.PENDING
)
error_message = models.TextField(null=True, blank=True)

# Timestamps
created_at = models.DateTimeField(auto_now_add=True)
updated_at = models.DateTimeField(auto_now=True)

class Meta:
    ordering = ["-created_at"]
    verbose_name = "Trip Calculation"
    verbose_name_plural = "Trip Calculations"
    indexes = [
        models.Index(fields=["-created_at"]),
        models.Index(fields=["status"]),
    ]

def __str__(self) -> str:
    return f"Trip {self.id}: {self.current_location} -> {self.dropoff_location}"

@property
def is_completed(self) -> bool:
    """Check if trip calculation is completed."""
    return self.status == "completed"

@property
def is_failed(self) -> bool:
    """Check if trip calculation failed."""
    return self.status == "failed"

def get_route_segments(self) -> list[dict[str, Any]]:
    """Get route segments from route_data."""
    if self.route_data and isinstance(self.route_data, dict):
        return self.route_data.get("segments", [])
    return []

def get_daily_logs(self) -> list[dict[str, Any]]:
    """Get daily logs."""
    if self.logs_data and isinstance(self.logs_data, list):
        return self.logs_data
    return []
================================================
FILE: eld_logs/route_calculator/serializers.py
from rest_framework import serializers

from .models import TripCalculation

class TripCalculationSerializer(serializers.ModelSerializer):
"""Serializer for TripCalculation model."""

text
class Meta:
    model = TripCalculation
    fields = [
        "id",
        "created_at",
        "updated_at",
        "current_location",
        "pickup_location",
        "dropoff_location",
        "current_cycle_used",
        "total_distance",
        "total_driving_time",
        "total_trip_time",
        "route_data",
        "logs_data",
        "coordinates",
        "status",
        "error_message",
    ]
    read_only_fields = [
        "id",
        "created_at",
        "updated_at",
        "total_distance",
        "total_driving_time",
        "total_trip_time",
        "route_data",
        "logs_data",
        "coordinates",
        "status",
        "error_message",
    ]
class TripInputSerializer(serializers.Serializer):
"""Serializer for trip calculation input."""

text
current_location = serializers.CharField(max_length=255)
pickup_location = serializers.CharField(max_length=255)
dropoff_location = serializers.CharField(max_length=255)
current_cycle_used = serializers.FloatField(
    min_value=0,
    max_value=70,
)

def validate_current_cycle_used(self, value: float) -> float:
    """Validate current cycle hours."""
    if value < 0 or value > 70:
        raise serializers.ValidationError(
            "Current cycle hours must be between 0 and 70"
        )
    return value
class TripResultSerializer(serializers.Serializer):
"""Serializer for trip calculation result response."""

text
id = serializers.IntegerField()
status = serializers.CharField()
message = serializers.CharField()
total_distance = serializers.FloatField(required=False)
total_driving_time = serializers.FloatField(required=False)
total_trip_time = serializers.FloatField(required=False)
route_data = serializers.JSONField(required=False)
logs_data = serializers.JSONField(required=False)
error_message = serializers.CharField(required=False)
================================================
FILE: eld_logs/route_calculator/tasks.py
import logging
from datetime import datetime, timedelta
from typing import Any, Optional

from celery import shared_task

from .models import TripCalculation
from .services.hos_calculator import HOSCalculator
from .services.route_service import RouteService

logger = logging.getLogger(name)

@shared_task(bind=True, max_retries=3)
def calculate_trip_task(self, trip_id: int) -> Optional[int]:
"""
Async task to calculate trip route and generate FMCSA-compliant logs.

text
Args:
    trip_id: ID of TripCalculation instance

Returns:
    Trip ID if successful, None otherwise
"""
try:
    trip = TripCalculation.objects.get(id=trip_id)
    trip.status = TripCalculation.JobStatus.PROCESSING
    trip.save()

    logger.info("Starting calculation for trip %s", trip_id)

    # Initialize services
    route_service = RouteService()

    # Geocode locations
    current_coord = route_service.geocode_location(trip.current_location)
    pickup_coord = route_service.geocode_location(trip.pickup_location)
    dropoff_coord = route_service.geocode_location(trip.dropoff_location)

    if not all([current_coord, pickup_coord, dropoff_coord]):
        raise ValueError("Could not geocode one or more locations")

    # Store coordinates
    trip.coordinates = {
        "current": current_coord,
        "pickup": pickup_coord,
        "dropoff": dropoff_coord,
    }
    trip.save()

    # Build coordinates for routing
    coordinates = [
        [current_coord["lon"], current_coord["lat"]],
        [pickup_coord["lon"], pickup_coord["lat"]],
        [dropoff_coord["lon"], dropoff_coord["lat"]],
    ]

    # Get route
    route = route_service.get_route(coordinates)
    if not route:
        raise ValueError("Could not calculate route")

    # Extract route legs
    route_legs = route_service.get_route_legs(route)
    if not route_legs:
        raise ValueError("No route legs found")

    # Calculate totals
    total_distance = sum(leg["distance"] for leg in route_legs)
    total_duration = sum(leg["duration"] for leg in route_legs)

    logger.info(
        "Route calculated: %.2f miles, %.2f hours",
        total_distance,
        total_duration,
    )

    # Calculate HOS compliance
    hos_calc = HOSCalculator(trip.current_cycle_used)

    segments, daily_logs_summary = hos_calc.calculate_trip_segments(
        total_distance=total_distance,
        start_location=trip.current_location,
        pickup_location=trip.pickup_location,
        dropoff_location=trip.dropoff_location,
        route_legs=route_legs,
    )

    # Calculate totals from segments
    total_driving_time = sum(
        s["duration"] for s in segments if s["type"] == "drive"
    )
    total_trip_time = sum(s["duration"] for s in segments)

    # Convert to FMCSA logs
    daily_logs = _convert_to_fmcsa_logs(
        trip_id=trip_id,  # Pass trip_id
        segments=segments,
        daily_logs_summary=daily_logs_summary,
        current_location=trip.current_location,
        pickup_location=trip.pickup_location,
        dropoff_location=trip.dropoff_location,
        total_distance=total_distance,
    )

    # Persist results
    trip.total_distance = round(total_distance, 2)
    trip.total_driving_time = round(total_driving_time, 2)
    trip.total_trip_time = round(total_trip_time, 2)
    trip.route_data = {
        "segments": segments,
        "geometry": route.get("features", [{}])[0].get("geometry"),
    }
    trip.logs_data = daily_logs
    trip.status = TripCalculation.JobStatus.COMPLETED
    trip.save()

    logger.info("Trip %s calculation completed successfully", trip_id)
    return trip_id

except TripCalculation.DoesNotExist:
    logger.error("Trip %s not found", trip_id)
    return None

except Exception as e:
    logger.error("Error calculating trip %s: %s", trip_id, e, exc_info=True)

    try:
        trip = TripCalculation.objects.get(id=trip_id)
        trip.status = TripCalculation.JobStatus.FAILED
        trip.error_message = str(e)
        trip.save()
    except Exception:
        pass

    # Retry with exponential backoff
    raise self.retry(exc=e, countdown=60)
def _convert_to_fmcsa_logs(
trip_id: int, # Added trip_id parameter
segments: list[dict[str, Any]],
daily_logs_summary: list[dict[str, Any]],
current_location: str,
pickup_location: str,
dropoff_location: str,
total_distance: float,
) -> list[dict[str, Any]]:
"""
Convert HOS segments into FMCSA-compliant daily log format.

text
Each log must contain:
- events: list of duty status changes with start/end times
- date: date of the log
- total_miles: miles driven that day
- remarks: location changes
"""
daily_logs: list[dict[str, Any]] = []
base_date = datetime.now()

# Group segments by 24-hour periods
day_segments: list[list[dict[str, Any]]] = []
current_day_segments: list[dict[str, Any]] = []
cumulative_time = 0.0

for segment in segments:
    duration = segment["duration"]

    # Check if segment crosses midnight
    if cumulative_time + duration > 24.0:
        time_in_current_day = 24.0 - cumulative_time

        if time_in_current_day > 0:
            # Add portion to current day
            current_day_segments.append(
                {
                    **segment,
                    "start_time": cumulative_time,
                    "end_time": 24.0,
                    "duration": time_in_current_day,
                }
            )

        # Save current day
        day_segments.append(current_day_segments)
        current_day_segments = []

        # Add remainder to next day
        remaining = duration - time_in_current_day
        if remaining > 0:
            current_day_segments.append(
                {
                    **segment,
                    "start_time": 0.0,
                    "end_time": remaining,
                    "duration": remaining,
                }
            )
            cumulative_time = remaining
        else:
            cumulative_time = 0.0
    else:
        # Segment fits in current day
        current_day_segments.append(
            {
                **segment,
                "start_time": cumulative_time,
                "end_time": cumulative_time + duration,
                "duration": duration,
            }
        )
        cumulative_time += duration

    # Check if we've completed a 24-hour period
    if cumulative_time >= 24.0:
        day_segments.append(current_day_segments)
        current_day_segments = []
        cumulative_time = 0.0

# Add remaining segments
if current_day_segments:
    day_segments.append(current_day_segments)

# Build FMCSA logs for each day
for day_index, day_segs in enumerate(day_segments):
    log_date = base_date + timedelta(days=day_index)

    events: list[dict[str, Any]] = []
    remarks: list[dict[str, str]] = []
    day_miles = 0.0

    # Sort segments by start time
    day_segs.sort(key=lambda s: s["start_time"])

    # Determine from/to addresses for this day
    day_from_address = current_location if day_index == 0 else "En route"
    day_to_address = (
        dropoff_location if day_index == len(day_segments) - 1 else "En route"
    )

    for seg in day_segs:
        seg_type = seg["type"]

        # Skip start markers
        if seg_type == "start":
            continue

        # Map segment type to duty status
        if seg_type == "drive":
            status = "driving"
            day_miles += seg.get("distance", 0.0)
        elif seg_type in ["pickup", "dropoff", "fuel"]:
            status = "onDuty"
        elif seg_type == "rest":
            status = "sleeper"
        elif seg_type == "break":
            status = "offDuty"
        else:
            status = "onDuty"

        # Add event
        events.append(
            {
                "start": seg["start_time"],
                "end": seg["end_time"],
                "status": status,
            }
        )

        # Add location remark for significant events
        location = seg.get("location", "")
        if location and location not in ["En route", "Highway"]:
            remarks.append(
                {
                    "time": seg["start_time"],
                    "location": location,
                }
            )

    # Ensure 24-hour coverage - fill remaining time with off-duty
    if events and events[-1]["end"] < 24.0:
        events.append(
            {
                "start": events[-1]["end"],
                "end": 24.0,
                "status": "offDuty",
            }
        )

    # Create daily log entry with all required fields
    daily_logs.append(
        {
            "date": log_date.strftime("%m/%d/%Y"),
            "events": events,
            "total_miles": round(day_miles, 1),
            "remarks": remarks,
            "driver_name": "Driver Name",
            "carrier_name": "Carrier Name",
            "main_office": "Washington, D.C.",
            "co_driver": "",
            "from_address": day_from_address,
            "to_address": day_to_address,
            "home_terminal_address": "Washington, D.C.",
            "truck_number": "101",
            "shipping_doc": f"BOL-{trip_id}",
        }
    )

return daily_logs
================================================
FILE: eld_logs/route_calculator/tests.py
from django.test import TestCase

Create your tests here.
================================================
FILE: eld_logs/route_calculator/urls.py
from django.urls import include, path
from rest_framework.routers import DefaultRouter

from .views import TripCalculationViewSet

router = DefaultRouter()
router.register(r"trips", TripCalculationViewSet, basename="trip")

urlpatterns = [
path("", include(router.urls)),
]

================================================
FILE: eld_logs/route_calculator/views.py
import logging
from typing import Any

from django.http import HttpResponse
from drf_spectacular.utils import (
OpenApiParameter,
OpenApiResponse,
extend_schema,
extend_schema_view,
)
from rest_framework import status, viewsets
from rest_framework.decorators import action
from rest_framework.request import Request
from rest_framework.response import Response

from .models import TripCalculation
from .serializers import TripCalculationSerializer, TripInputSerializer
from .services.log_generator import LogGenerator
from .services.map_generator import MapGenerator
from .tasks import calculate_trip_task

logger = logging.getLogger(name)

@extend_schema_view(
list=extend_schema(
tags=["Trips"],
summary="List trip calculations",
description="Retrieve a paginated list of trip calculations.",
responses={200: TripCalculationSerializer(many=True)},
),
retrieve=extend_schema(
tags=["Trips"],
summary="Retrieve a trip calculation",
description="Retrieve a single trip calculation by ID.",
responses={200: TripCalculationSerializer},
),
create=extend_schema(
tags=["Trips"],
summary="Create trip calculation (unused)",
description="Trip calculations are created via the calculate endpoint.",
exclude=True,
),
)
class TripCalculationViewSet(viewsets.ModelViewSet):
"""
API endpoints for trip route calculation, FMCSA HOS logs,
ELD daily logs, and route map visualization.
"""

text
queryset = TripCalculation.objects.all()
serializer_class = TripCalculationSerializer

def get_queryset(self):
    """Return trips ordered by most recent."""
    return TripCalculation.objects.all().order_by("-created_at")

# =========================================================================
# Calculate Trip
# =========================================================================
@extend_schema(
    tags=["Trips"],
    summary="Calculate route and generate logs",
    description=(
        "Starts an asynchronous trip calculation including:\n"
        "- Route calculation (OpenRouteService)\n"
        "- FMCSA HOS compliance\n"
        "- ELD daily logs\n"
        "- Route map generation\n\n"
        "Returns immediately with a processing status."
    ),
    request=TripInputSerializer,
    responses={
        202: OpenApiResponse(
            description="Trip calculation started",
            response={
                "type": "object",
                "properties": {
                    "id": {"type": "integer"},
                    "status": {"type": "string"},
                    "message": {"type": "string"},
                },
            },
        ),
        400: OpenApiResponse(description="Invalid input"),
    },
)
@action(detail=False, methods=["post"], url_path="calculate")
def calculate(self, request: Request) -> Response:
    """Start async trip calculation."""
    serializer = TripInputSerializer(data=request.data)
    if not serializer.is_valid():
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    trip = TripCalculation.objects.create(
        current_location=serializer.validated_data["current_location"],
        pickup_location=serializer.validated_data["pickup_location"],
        dropoff_location=serializer.validated_data["dropoff_location"],
        current_cycle_used=serializer.validated_data["current_cycle_used"],
        status=TripCalculation.JobStatus.PENDING,
    )

    calculate_trip_task.delay(trip.id)

    logger.info("Trip calculation initiated: %s", trip.id)

    return Response(
        {
            "id": trip.id,
            "status": "processing",
            "message": "Trip calculation started. Use the result endpoint to check status.",
        },
        status=status.HTTP_202_ACCEPTED,
    )

# =========================================================================
# Get Result
# =========================================================================
@extend_schema(
    tags=["Trips"],
    summary="Get calculation result",
    description="Retrieve the full calculation result including route, logs, and totals.",
    responses={
        200: TripCalculationSerializer,
        404: OpenApiResponse(description="Trip not found"),
    },
)
@action(detail=True, methods=["get"], url_path="result")
def result(self, request: Request, pk: Any = None) -> Response:
    """Get calculation result."""
    trip = self.get_object()
    serializer = self.get_serializer(trip)
    return Response(serializer.data)

# =========================================================================
# Download Daily Log
# =========================================================================
@extend_schema(
    tags=["Logs"],
    summary="Download ELD daily log image",
    description="Download a PNG image of the FMCSA-compliant ELD daily log.",
    parameters=[
        OpenApiParameter(
            name="day",
            description="Day number of the trip (1-based)",
            required=False,
            type=int,
        )
    ],
    responses={
        200: OpenApiResponse(
            description="PNG image",
            response={"image/png": {"type": "string", "format": "binary"}},
        ),
        404: OpenApiResponse(description="Log not found"),
        400: OpenApiResponse(description="Invalid log data"),
    },
)
@action(detail=True, methods=["get"], url_path="download-log")
def download_log(self, request: Request, pk: Any = None) -> HttpResponse:
    """Download ELD log image."""
    try:
        trip = self.get_object()
        day = int(request.query_params.get("day", 1))

        if not trip.logs_data or day < 1 or day > len(trip.logs_data):
            return Response(
                {"error": f"Log for day {day} not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

        log_data = trip.logs_data[day - 1]

        # Validate required fields
        required_fields = ["events", "date", "total_miles"]
        missing = [f for f in required_fields if f not in log_data]
        if missing:
            return Response(
                {"error": f"Log data missing required fields: {missing}"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Extract all log fields with defaults from log_data
        driver_name = log_data.get("driver_name", "Driver Name")
        carrier_name = log_data.get("carrier_name", "Carrier Name")
        main_office = log_data.get("main_office", "Washington, D.C.")
        co_driver = log_data.get("co_driver", "")
        from_address = log_data.get("from_address", "")
        to_address = log_data.get("to_address", "")
        home_terminal_address = log_data.get("home_terminal_address", main_office)
        truck_number = log_data.get("truck_number", "")
        shipping_doc = log_data.get("shipping_doc", "")

        generator = LogGenerator()
        image_bytes = generator.generate_log_image(
            log_data=log_data,
            day_number=day,
            driver_name=driver_name,
            carrier_name=carrier_name,
            main_office=main_office,
            co_driver=co_driver,
            from_address=from_address,
            to_address=to_address,
            home_terminal_address=home_terminal_address,
            truck_number=truck_number,
            shipping_doc=shipping_doc,
        )

        response = HttpResponse(image_bytes, content_type="image/png")
        response["Content-Disposition"] = (
            f'attachment; filename="eld_log_trip_{trip.id}_day_{day}.png"'
        )

        logger.info("Log downloaded: Trip %s, Day %s", trip.id, day)
        return response

    except ValueError:
        return Response(
            {"error": "Invalid day parameter"},
            status=status.HTTP_400_BAD_REQUEST,
        )
    except Exception as e:
        logger.error("Error generating log image: %s", e, exc_info=True)
        return Response(
            {"error": "Error generating log image"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR,
        )

# =========================================================================
# Download Route Map
# =========================================================================
@extend_schema(
    tags=["Maps"],
    summary="Download route map",
    description=(
        "Download a PNG map visualizing the trip route following actual roads. "
        "The route geometry comes from OpenRouteService and shows the real path "
        "the driver will take, not just straight lines between waypoints."
    ),
    responses={
        200: OpenApiResponse(
            description="PNG image",
            response={"image/png": {"type": "string", "format": "binary"}},
        ),
        404: OpenApiResponse(description="Route data not available"),
        400: OpenApiResponse(description="Invalid coordinates"),
    },
)
@action(detail=True, methods=["get"], url_path="download-map")
def download_map(self, request: Request, pk: Any = None) -> HttpResponse:
    """Download route map image with actual road geometry."""
    try:
        trip = self.get_object()

        # Check if coordinates are available
        if not trip.coordinates:
            return Response(
                {"error": "Coordinates not available for this trip"},
                status=status.HTTP_404_NOT_FOUND,
            )

        # Extract and validate coordinates
        current_coord = trip.coordinates.get("current", {})
        pickup_coord = trip.coordinates.get("pickup", {})
        dropoff_coord = trip.coordinates.get("dropoff", {})

        # Validate each coordinate has required fields
        for coord, name in [
            (current_coord, "current"),
            (pickup_coord, "pickup"),
            (dropoff_coord, "dropoff"),
        ]:
            if "lat" not in coord or "lon" not in coord:
                return Response(
                    {"error": f"Invalid {name} coordinates"},
                    status=status.HTTP_400_BAD_REQUEST,
                )

        # Build coordinates list for map generator
        coordinates = [
            {
                "lat": current_coord["lat"],
                "lon": current_coord["lon"],
                "name": current_coord.get("name", "Start"),
            },
            {
                "lat": pickup_coord["lat"],
                "lon": pickup_coord["lon"],
                "name": pickup_coord.get("name", "Pickup"),
            },
            {
                "lat": dropoff_coord["lat"],
                "lon": dropoff_coord["lon"],
                "name": dropoff_coord.get("name", "Dropoff"),
            },
        ]

        # Get segments and geometry from route_data
        segments = []
        geometry = None

        if trip.route_data:
            segments = trip.route_data.get("segments", [])
            # This is the actual road geometry from OpenRouteService!
            # It contains the polyline that follows real roads
            geometry = trip.route_data.get("geometry")

        # Generate map with actual route geometry
        generator = MapGenerator()
        image_bytes = generator.generate_route_map(
            coordinates=coordinates,
            segments=segments,
            geometry=geometry,  # Pass the ORS geometry for road-following route
        )

        response = HttpResponse(image_bytes, content_type="image/png")
        response["Content-Disposition"] = (
            f'attachment; filename="route_map_trip_{trip.id}.png"'
        )

        logger.info(
            "Route map downloaded: Trip %s (geometry: %s)",
            trip.id,
            "yes" if geometry else "no",
        )
        return response

    except Exception as e:
        logger.error("Error generating route map: %s", e, exc_info=True)
        return Response(
            {"error": "Error generating route map"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR,
        )

# =========================================================================
# Get Trip Status
# =========================================================================
@extend_schema(
    tags=["Trips"],
    summary="Get trip status",
    description="Get the current processing status of a trip calculation.",
    responses={
        200: OpenApiResponse(
            description="Trip status",
            response={
                "type": "object",
                "properties": {
                    "id": {"type": "integer"},
                    "status": {"type": "string"},
                    "error_message": {"type": "string", "nullable": True},
                },
            },
        ),
        404: OpenApiResponse(description="Trip not found"),
    },
)
@action(detail=True, methods=["get"], url_path="status")
def get_status(self, request: Request, pk: Any = None) -> Response:
    """Get trip calculation status."""
    trip = self.get_object()
    return Response(
        {
            "id": trip.id,
            "status": trip.status,
            "error_message": trip.error_message,
        }
    )

# =========================================================================
# Get Trip Summary
# =========================================================================
@extend_schema(
    tags=["Trips"],
    summary="Get trip summary",
    description="Get a summary of the trip including distances and times.",
    responses={
        200: OpenApiResponse(
            description="Trip summary",
            response={
                "type": "object",
                "properties": {
                    "id": {"type": "integer"},
                    "status": {"type": "string"},
                    "current_location": {"type": "string"},
                    "pickup_location": {"type": "string"},
                    "dropoff_location": {"type": "string"},
                    "total_distance": {"type": "number", "nullable": True},
                    "total_driving_time": {"type": "number", "nullable": True},
                    "total_trip_time": {"type": "number", "nullable": True},
                    "num_days": {"type": "integer"},
                    "created_at": {"type": "string", "format": "date-time"},
                },
            },
        ),
        404: OpenApiResponse(description="Trip not found"),
    },
)
@action(detail=True, methods=["get"], url_path="summary")
def summary(self, request: Request, pk: Any = None) -> Response:
    """Get trip summary."""
    trip = self.get_object()

    num_days = len(trip.logs_data) if trip.logs_data else 0

    return Response(
        {
            "id": trip.id,
            "status": trip.status,
            "current_location": trip.current_location,
            "pickup_location": trip.pickup_location,
            "dropoff_location": trip.dropoff_location,
            "total_distance": trip.total_distance,
            "total_driving_time": trip.total_driving_time,
            "total_trip_time": trip.total_trip_time,
            "num_days": num_days,
            "created_at": trip.created_at.isoformat(),
        }
    )

# =========================================================================
# List Daily Logs
# =========================================================================
@extend_schema(
    tags=["Logs"],
    summary="List daily logs",
    description="Get a list of all daily logs for a trip with basic info.",
    responses={
        200: OpenApiResponse(
            description="List of daily logs",
            response={
                "type": "object",
                "properties": {
                    "trip_id": {"type": "integer"},
                    "total_days": {"type": "integer"},
                    "logs": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "day": {"type": "integer"},
                                "date": {"type": "string"},
                                "total_miles": {"type": "number"},
                                "download_url": {"type": "string"},
                            },
                        },
                    },
                },
            },
        ),
        404: OpenApiResponse(description="Trip not found or no logs available"),
    },
)
@action(detail=True, methods=["get"], url_path="logs")
def list_logs(self, request: Request, pk: Any = None) -> Response:
    """List all daily logs for a trip."""
    trip = self.get_object()

    if not trip.logs_data:
        return Response(
            {"error": "No logs available for this trip"},
            status=status.HTTP_404_NOT_FOUND,
        )

    logs_info = []
    for i, log in enumerate(trip.logs_data, start=1):
        logs_info.append(
            {
                "day": i,
                "date": log.get("date", ""),
                "total_miles": log.get("total_miles", 0),
                "from_address": log.get("from_address", ""),
                "to_address": log.get("to_address", ""),
                "download_url": f"/api/trips/{trip.id}/download-log/?day={i}",
            }
        )

    return Response(
        {
            "trip_id": trip.id,
            "total_days": len(trip.logs_data),
            "logs": logs_info,
        }
    )
theres more


Thought Process
expand
I can see the codebase structure now. This is a well-organized Django project with:

Celery for async task processing
DRF with good API documentation
OpenRouteService for routing
Please share the remaining files, especially the services:

services/map_generator.py (critical for the async task requirement)
services/log_generator.py
services/route_service.py
services/hos_calculator.py
Initial Observations
Aspect	Current State	Improvement Needed
Database	SQLite only	Add PostgreSQL support ✅
Map Generation	Synchronous in view	Move to Celery task ✅
Task Status	Basic polling only	Add WebSocket/SSE for real-time updates
Type Hints	Good coverage	✅ Already good
API Docs	drf-spectacular	✅ Already good
Error Handling	Basic	Could be improved
Key Issues I've Already Spotted
Map generation is blocking - download_map runs synchronously
No PostgreSQL configuration - Only SQLite in settings
No task progress tracking - Frontend can only poll status
Missing database indexes - Could optimize queries
No connection pooling - Important for PostgreSQL
Retry logic could be improved - Current retry is basic
Once you share the services, I'll provide:

Complete PostgreSQL integration
Async map generation with progress tracking
WebSocket/SSE implementation for real-time updates
Improved error handling and logging
Database optimizations
Please paste the service files to continue!

Claude Opus 4.5
================================================
FILE: eld_logs/route_calculator/migrations/0001_initial.py
Generated by Django 6.0 on 2025-12-14 15:44
from django.db import migrations, models

class Migration(migrations.Migration):

text
initial = True

dependencies = []

operations = [
    migrations.CreateModel(
        name="TripCalculation",
        fields=[
            (
                "id",
                models.BigAutoField(
                    auto_created=True,
                    primary_key=True,
                    serialize=False,
                    verbose_name="ID",
                ),
            ),
            ("current_location", models.CharField(max_length=255)),
            ("pickup_location", models.CharField(max_length=255)),
            ("dropoff_location", models.CharField(max_length=255)),
            ("current_cycle_used", models.FloatField()),
            ("total_distance", models.FloatField(blank=True, null=True)),
            ("total_driving_time", models.FloatField(blank=True, null=True)),
            ("total_trip_time", models.FloatField(blank=True, null=True)),
            ("route_data", models.JSONField(blank=True, null=True)),
            ("logs_data", models.JSONField(blank=True, null=True)),
            ("coordinates", models.JSONField(blank=True, null=True)),
            (
                "status",
                models.CharField(
                    choices=[
                        ("pending", "Pending"),
                        ("processing", "Processing"),
                        ("completed", "Completed"),
                        ("failed", "Failed"),
                    ],
                    default="pending",
                    max_length=20,
                ),
            ),
            ("error_message", models.TextField(blank=True, null=True)),
            ("created_at", models.DateTimeField(auto_now_add=True)),
            ("updated_at", models.DateTimeField(auto_now=True)),
        ],
        options={
            "verbose_name": "Trip Calculation",
            "verbose_name_plural": "Trip Calculations",
            "ordering": ["-created_at"],
            "indexes": [
                models.Index(
                    fields=["-created_at"], name="route_calcu_created_5cfc0e_idx"
                ),
                models.Index(
                    fields=["status"], name="route_calcu_status_65f9a6_idx"
                ),
            ],
        },
    ),
]
================================================
FILE: eld_logs/route_calculator/migrations/init.py
[Empty file]

================================================
FILE: eld_logs/route_calculator/services/hos_calculator.py
import logging
from typing import Any

logger = logging.getLogger(name)

class HOSCalculator:
"""
FMCSA Property-Carrying Driver Hours of Service Calculator.

text
Implements:
- 11-hour driving limit
- 14-hour duty window
- 70-hour/8-day cycle
- 10-hour rest period requirement
- Fuel stops every 1,000 miles
"""

# FMCSA limits
MAX_DRIVING_TIME: float = 11.0
MAX_DUTY_WINDOW: float = 14.0
MAX_CYCLE_HOURS: float = 70.0
REST_PERIOD: float = 10.0

# Operational parameters
FUEL_INTERVAL_MILES: float = 1000.0
FUEL_TIME: float = 0.5
PICKUP_TIME: float = 1.0
DROPOFF_TIME: float = 1.0
AVERAGE_SPEED: float = 55.0  # mph

def __init__(self, cycle_used: float) -> None:
    """
    Initialize HOS Calculator.

    Args:
        cycle_used: Hours already used in current 70-hour/8-day cycle
    """
    if cycle_used < 0 or cycle_used > self.MAX_CYCLE_HOURS:
        raise ValueError(
            f"Cycle hours must be between 0 and {self.MAX_CYCLE_HOURS}"
        )
    self.cycle_used = cycle_used
    self.remaining_cycle = self.MAX_CYCLE_HOURS - cycle_used

def calculate_trip_segments(
    self,
    total_distance: float,
    start_location: str,
    pickup_location: str,
    dropoff_location: str,
    route_legs: list[dict[str, float]],
) -> tuple[list[dict[str, Any]], list[dict[str, Any]]]:
    """
    Calculate trip segments with HOS compliance.

    Args:
        total_distance: Total trip distance in miles
        start_location: Starting location name
        pickup_location: Pickup location name
        dropoff_location: Dropoff location name
        route_legs: list of route legs with distance and duration

    Returns:
        tuple of (segments, daily_logs_summary)
    """
    segments: list[dict[str, Any]] = []

    # Tracking variables
    drive_today: float = 0.0
    duty_today: float = 0.0
    miles_since_fuel: float = 0.0
    total_miles_driven: float = 0.0

    # Start segment
    segments.append(
        {
            "type": "start",
            "duration": 0.0,
            "distance": 0.0,
            "location": start_location,
        }
    )

    # Pickup
    segments.append(
        {
            "type": "pickup",
            "duration": self.PICKUP_TIME,
            "distance": 0.0,
            "location": pickup_location,
        }
    )
    duty_today += self.PICKUP_TIME

    # Calculate remaining distance to drive
    remaining_distance = total_distance

    # Process route legs
    for leg in route_legs:
        leg_miles = leg["distance"]
        leg_hours = leg["duration"]

        logger.debug(
            f"Processing leg: {leg_miles:.2f} miles, {leg_hours:.2f} hours"
        )

        while leg_hours > 0 and remaining_distance > 0:
            # Check if we need rest
            if (
                drive_today >= self.MAX_DRIVING_TIME
                or duty_today >= self.MAX_DUTY_WINDOW
            ):
                logger.debug(
                    f"Rest needed - Drive: {drive_today:.2f}h, "
                    f"Duty: {duty_today:.2f}h"
                )

                segments.append(
                    {
                        "type": "rest",
                        "duration": self.REST_PERIOD,
                        "distance": 0.0,
                        "location": "Rest Area",
                    }
                )

                # Reset daily counters
                drive_today = 0.0
                duty_today = 0.0
                continue

            # Check if we need fuel
            if (
                miles_since_fuel >= self.FUEL_INTERVAL_MILES
                and remaining_distance > 100
            ):
                segments.append(
                    {
                        "type": "fuel",
                        "duration": self.FUEL_TIME,
                        "distance": 0.0,
                        "location": "Fuel Station",
                    }
                )
                duty_today += self.FUEL_TIME
                miles_since_fuel = 0.0
                continue

            # Calculate available driving time
            drive_available = min(
                self.MAX_DRIVING_TIME - drive_today,
                self.MAX_DUTY_WINDOW - duty_today,
            )

            if drive_available <= 0:
                continue

            # Drive segment
            drive_hours = min(
                drive_available, leg_hours, remaining_distance / self.AVERAGE_SPEED
            )
            drive_miles = min(drive_hours * self.AVERAGE_SPEED, remaining_distance)

            segments.append(
                {
                    "type": "drive",
                    "duration": round(drive_hours, 2),
                    "distance": round(drive_miles, 2),
                    "location": "En route",
                }
            )

            # Update counters
            leg_hours -= drive_hours
            remaining_distance -= drive_miles
            drive_today += drive_hours
            duty_today += drive_hours
            miles_since_fuel += drive_miles
            total_miles_driven += drive_miles

            logger.debug(
                f"Drove {drive_miles:.2f} miles in {drive_hours:.2f} hours. "
                f"Remaining: {remaining_distance:.2f} miles"
            )

    # Dropoff
    segments.append(
        {
            "type": "dropoff",
            "duration": self.DROPOFF_TIME,
            "distance": 0.0,
            "location": dropoff_location,
        }
    )

    # Generate daily summary (simple version)
    daily_logs_summary = self._generate_daily_summary(segments)

    logger.info(
        f"Generated {len(segments)} segments, " f"{len(daily_logs_summary)} days"
    )

    return segments, daily_logs_summary

def _generate_daily_summary(
    self, segments: list[dict[str, Any]]
) -> list[dict[str, Any]]:
    """Generate simplified daily summary."""
    # Simple implementation - can be enhanced
    return [
        {"day": 1, "driving": 0.0, "onDuty": 0.0, "sleeper": 0.0, "offDuty": 0.0}
    ]
================================================
FILE: eld_logs/route_calculator/services/log_generator.py
import io
import logging
from datetime import datetime
from typing import Any

from django.conf import settings
from django.contrib.staticfiles import finders
from PIL import Image, ImageDraw, ImageFont

logger = logging.getLogger(name)

class LogGenerator:
"""
Generate FMCSA-compliant Driver Daily Log images
using centered duty-status lines.
"""

text
template_filename = settings.TEMPLATE_FILENAME

# -------------------------------------------------
# GRID GEOMETRY (CALIBRATED)
# -------------------------------------------------
GRID_START_X = 65  # Midnight X
GRID_START_Y = 185  # Off-duty row Y

HOUR_WIDTH = 16.2  # px per hour
ROW_HEIGHT = 17  # px per duty row
TOTAL_HOURS_OFFSET = 20  # px after last midnight

STATUS_ROW_INDEX = {
    "offDuty": 0,
    "sleeper": 1,
    "driving": 2,
    "onDuty": 3,
}

# -------------------------------------------------
# REMARKS SECTION
# -------------------------------------------------
# X position where first remark starts (aligned with grid)
REMARKS_START_X = 68
# Y position for the BOTTOM of the vertical text (the baseline)
REMARKS_BASELINE_Y = 335
# Horizontal spacing between each remark
REMARKS_SPACING_X = 65

# -------------------------------------------------
# COLORS
# -------------------------------------------------
COLOR_DUTY_LINE = (0, 102, 204)  # Blue
COLOR_TEXT = (0, 0, 0)

# -------------------------------------------------
# GRAND TOTAL POSITION
# -------------------------------------------------
GRAND_TOTAL_X = 465
GRAND_TOTAL_Y = 268

# -------------------------------------------------
# HEADER FIELD POSITIONS
# -------------------------------------------------
# Date fields
DATE_MONTH_X = 180
DATE_DAY_X = 225
DATE_YEAR_X = 260
DATE_Y = 8

# Total miles
TOTAL_MILES_X = 85
TOTAL_MILES_Y = 70

# From address
FROM_ADDRESS_X = 90
FROM_ADDRESS_Y = 35

# To address
TO_ADDRESS_X = 300
TO_ADDRESS_Y = 35

# Home terminal address
HOME_TERMINAL_X = 240
HOME_TERMINAL_Y = 90

# Carrier name
CARRIER_NAME_X = 240
CARRIER_NAME_Y = 70

# Driver name
DRIVER_NAME_X = 240
DRIVER_NAME_Y = 110

# Truck/Tractor number
TRUCK_NUMBER_X = 90
TRUCK_NUMBER_Y = 105

# Shipping document number
SHIPPING_DOC_X = 30
SHIPPING_DOC_Y = 345

# Co-driver name
CO_DRIVER_X = 620
CO_DRIVER_Y = 110

def __init__(self) -> None:
    self.fonts = self._load_fonts()

def _get_template_path(self) -> str:
    """Get template path using Django's static file finder."""
    path = finders.find(self.template_filename)
    if not path:
        raise FileNotFoundError(
            f"Static file '{self.template_filename}' not found. "
            "Ensure it exists in one of your STATICFILES_DIRS."
        )
    return path

# -------------------------------------------------
# FONT LOADING
# -------------------------------------------------
def _load_fonts(self) -> dict[str, ImageFont.FreeTypeFont]:
    paths = [
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
        "/System/Library/Fonts/Helvetica.ttc",
        "C:\\Windows\\Fonts\\arial.ttf",
    ]

    for font_path in paths:
        try:
            return {
                "x-small": ImageFont.truetype(font_path, 9),
                "small": ImageFont.truetype(font_path, 11),
                "medium": ImageFont.truetype(font_path, 10),
            }
        except Exception:
            continue

    logger.warning("Could not load TrueType fonts, using default")
    default_font = ImageFont.load_default()
    return {"x-small": default_font, "small": default_font, "medium": default_font}

# -------------------------------------------------
# MAIN ENTRY POINT
# -------------------------------------------------
def generate_log_image(
    self,
    log_data: dict[str, Any],
    day_number: int,
    driver_name: str,
    carrier_name: str,
    main_office: str = "Washington, D.C.",
    co_driver: str = "",
    from_address: str = "",
    to_address: str = "",
    home_terminal_address: str = "",
    truck_number: str = "",
    shipping_doc: str = "",
) -> bytes:
    template_path = self._get_template_path()
    img = Image.open(template_path).convert("RGB")
    draw = ImageDraw.Draw(img)

    # Use log_data values as fallback if parameters are empty
    total_miles = log_data.get("total_miles", "")
    from_addr = from_address or log_data.get("from_address", "")
    to_addr = to_address or log_data.get("to_address", "")
    home_terminal = home_terminal_address or log_data.get(
        "home_terminal_address", main_office
    )
    truck_num = truck_number or log_data.get("truck_number", "")
    ship_doc = shipping_doc or log_data.get("shipping_doc", "")

    self._draw_header(
        draw=draw,
        log_data=log_data,
        driver_name=driver_name,
        carrier_name=carrier_name,
        main_office=main_office,
        co_driver=co_driver,
        total_miles=total_miles,
        from_address=from_addr,
        to_address=to_addr,
        home_terminal_address=home_terminal,
        truck_number=truck_num,
        shipping_doc=ship_doc,
    )
    totals = self._draw_duty_status_lines(draw, log_data.get("events", []))
    self._draw_totals(draw, totals)
    self._draw_grand_total(draw, totals)
    self._draw_remarks(img, log_data.get("remarks", []))

    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return buf.getvalue()

# -------------------------------------------------
# HEADER
# -------------------------------------------------
def _draw_header(
    self,
    draw: ImageDraw.ImageDraw,
    log_data: dict[str, Any],
    driver_name: str,
    carrier_name: str,
    main_office: str,
    co_driver: str,
    total_miles: Any,
    from_address: str,
    to_address: str,
    home_terminal_address: str,
    truck_number: str,
    shipping_doc: str,
) -> None:
    # Date
    date = log_data.get("date", datetime.now().strftime("%m/%d/%Y"))
    month, day, year = date.split("/")

    draw.text(
        (self.DATE_MONTH_X, self.DATE_Y),
        month,
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )
    draw.text(
        (self.DATE_DAY_X, self.DATE_Y),
        day,
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )
    draw.text(
        (self.DATE_YEAR_X, self.DATE_Y),
        year,
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )

    # Total miles
    draw.text(
        (self.TOTAL_MILES_X, self.TOTAL_MILES_Y),
        str(total_miles),
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )

    # From address
    draw.text(
        (self.FROM_ADDRESS_X, self.FROM_ADDRESS_Y),
        str(from_address),
        font=self.fonts["medium"],
        fill=self.COLOR_TEXT,
    )

    # To address
    draw.text(
        (self.TO_ADDRESS_X, self.TO_ADDRESS_Y),
        str(to_address),
        font=self.fonts["medium"],
        fill=self.COLOR_TEXT,
    )

    # Carrier name
    draw.text(
        (self.CARRIER_NAME_X, self.CARRIER_NAME_Y),
        carrier_name,
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )

    # Home terminal address
    draw.text(
        (self.HOME_TERMINAL_X, self.HOME_TERMINAL_Y),
        str(home_terminal_address),
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )

    # Driver name
    draw.text(
        (self.DRIVER_NAME_X, self.DRIVER_NAME_Y),
        driver_name,
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )

    # Truck/Tractor number
    draw.text(
        (self.TRUCK_NUMBER_X, self.TRUCK_NUMBER_Y),
        str(truck_number),
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )

    # Shipping document number
    draw.text(
        (self.SHIPPING_DOC_X, self.SHIPPING_DOC_Y),
        str(shipping_doc),
        font=self.fonts["x-small"],
        fill=self.COLOR_TEXT,
    )

    # Co-driver name
    if co_driver:
        draw.text(
            (self.CO_DRIVER_X, self.CO_DRIVER_Y),
            co_driver,
            font=self.fonts["small"],
            fill=self.COLOR_TEXT,
        )

# -------------------------------------------------
# DUTY STATUS LINES
# -------------------------------------------------
def _draw_duty_status_lines(
    self,
    draw: ImageDraw.ImageDraw,
    events: list[dict[str, Any]],
) -> dict[str, float]:
    totals = {k: 0.0 for k in self.STATUS_ROW_INDEX}
    prev_row_center_y = None

    for event in sorted(events, key=lambda e: float(e["start"])):
        status = event.get("status")
        if status not in self.STATUS_ROW_INDEX:
            continue

        start = max(0.0, float(event["start"]))
        end = min(24.0, float(event["end"]))
        duration = end - start

        row_index = self.STATUS_ROW_INDEX[status]
        row_top_y = self.GRID_START_Y + (row_index * self.ROW_HEIGHT)
        row_center_y = row_top_y + (self.ROW_HEIGHT // 2)

        x1 = int(self.GRID_START_X + (start * self.HOUR_WIDTH))
        x2 = int(self.GRID_START_X + (end * self.HOUR_WIDTH))

        if prev_row_center_y is not None and prev_row_center_y != row_center_y:
            draw.line(
                [(x1, prev_row_center_y), (x1, row_center_y)],
                fill=self.COLOR_DUTY_LINE,
                width=2,
            )

        draw.line(
            [(x1, row_center_y), (x2, row_center_y)],
            fill=self.COLOR_DUTY_LINE,
            width=2,
        )

        totals[status] += duration
        prev_row_center_y = row_center_y

    return totals

# -------------------------------------------------
# TOTAL HOURS PER STATUS
# -------------------------------------------------
def _draw_totals(
    self,
    draw: ImageDraw.ImageDraw,
    totals: dict[str, float],
) -> None:
    total_x = int(
        self.GRID_START_X + (24 * self.HOUR_WIDTH) + self.TOTAL_HOURS_OFFSET
    )

    for status, hours in totals.items():
        row_index = self.STATUS_ROW_INDEX[status]
        row_top_y = self.GRID_START_Y + (row_index * self.ROW_HEIGHT)
        row_center_y = row_top_y + (self.ROW_HEIGHT // 2)

        draw.text(
            (total_x, row_center_y - 6),
            f"{hours:.2f}",
            font=self.fonts["small"],
            fill=self.COLOR_TEXT,
        )

# -------------------------------------------------
# GRAND TOTAL (ALL STATUSES)
# -------------------------------------------------
def _draw_grand_total(
    self,
    draw: ImageDraw.ImageDraw,
    totals: dict[str, float],
) -> None:
    grand_total = sum(totals.values())

    draw.text(
        (self.GRAND_TOTAL_X, self.GRAND_TOTAL_Y),
        f"={grand_total:.2f}",
        font=self.fonts["small"],
        fill=self.COLOR_TEXT,
    )

# -------------------------------------------------
# REMARKS (VERTICAL TEXT, 90 DEGREES)
# -------------------------------------------------
# TODO: Fix remarks x positioning
def _draw_remarks(
    self,
    img: Image.Image,
    remarks: list[dict[str, str]],
) -> None:
    x = self.REMARKS_START_X

    for remark in remarks:
        location = remark.get("location")
        if not location:
            continue

        self._draw_vertical_text(
            img=img,
            x=x,
            baseline_y=self.REMARKS_BASELINE_Y,
            text=location,
        )

        x += self.REMARKS_SPACING_X

def _draw_vertical_text(
    self,
    img: Image.Image,
    x: int,
    baseline_y: int,
    text: str,
) -> None:
    """
    Draw text rotated 90 degrees counterclockwise.
    The text will read from bottom to top.

    Args:
        img: The image to draw on
        x: X position for the left edge of the rotated text
        baseline_y: Y position for the bottom of the rotated text
        text: The text to draw
    """
    font = self.fonts["x-small"]

    # Create a temporary image to measure and draw the text
    dummy = ImageDraw.Draw(img)
    bbox = dummy.textbbox((0, 0), text, font=font)
    text_w = bbox[2] - bbox[0]
    text_h = bbox[3] - bbox[1]

    # Add padding
    pad = 2
    txt_img = Image.new(
        "RGBA",
        (text_w + pad * 2, text_h + pad * 2),
        (255, 255, 255, 0),
    )

    txt_draw = ImageDraw.Draw(txt_img)
    txt_draw.text(
        (pad, pad),
        text,
        font=font,
        fill=self.COLOR_TEXT,
    )

    # Rotate 90 degrees counterclockwise
    # After rotation: original width becomes height, original height becomes width
    rotated = txt_img.rotate(90, expand=True)

    # Calculate paste position
    # After 90° CCW rotation:
    # - rotated.width = original height (text_h + pad*2)
    # - rotated.height = original width (text_w + pad*2)
    #
    # We want:
    # - Left edge of rotated text at x
    # - Bottom edge of rotated text at baseline_y
    paste_x = x
    paste_y = baseline_y - rotated.height

    img.paste(rotated, (paste_x, paste_y), rotated)

def _draw_rotated_text(
    self,
    img: Image.Image,
    x: int,
    y: int,
    text: str,
    angle: float,
) -> None:
    """
    Draw text at an arbitrary angle.
    For 90-degree rotation, use _draw_vertical_text instead for better positioning.

    Args:
        img: The image to draw on
        x: X position (interpretation depends on angle)
        y: Y position (interpretation depends on angle)
        text: The text to draw
        angle: Rotation angle in degrees (counterclockwise)
    """
    font = self.fonts["small"]

    # Measure text
    dummy = ImageDraw.Draw(img)
    bbox = dummy.textbbox((0, 0), text, font=font)
    text_w = bbox[2] - bbox[0]
    text_h = bbox[3] - bbox[1]

    pad = 4
    txt_img = Image.new(
        "RGBA",
        (text_w + pad * 2, text_h + pad * 2),
        (255, 255, 255, 0),
    )

    txt_draw = ImageDraw.Draw(txt_img)
    txt_draw.text(
        (pad, pad),
        text,
        font=font,
        fill=self.COLOR_TEXT,
    )

    # Rotate
    rotated = txt_img.rotate(angle, expand=True)

    # Position based on angle
    if angle == 90:
        # Text reads bottom to top
        # Bottom-left of rotated image at (x, y)
        paste_x = x
        paste_y = y - rotated.height
    elif angle == -90 or angle == 270:
        # Text reads top to bottom
        # Top-left of rotated image at (x, y)
        paste_x = x
        paste_y = y
    elif angle == 45:
        # Diagonal text - center around the point
        paste_x = x - rotated.width // 2
        paste_y = y - rotated.height // 2
    else:
        # Default: center the rotated text around (x, y)
        orig_cx = txt_img.width // 2
        orig_cy = txt_img.height // 2
        rot_cx = rotated.width // 2
        rot_cy = rotated.height // 2
        paste_x = int(x + orig_cx - rot_cx)
        paste_y = int(y + orig_cy - rot_cy)

    img.paste(rotated, (paste_x, paste_y), rotated)
================================================
FILE: eld_logs/route_calculator/services/map_generator.py
import io
import logging
from typing import Any, Optional

from PIL import Image, ImageDraw, ImageFont

logger = logging.getLogger(name)

Try to import staticmap for local tile rendering
try:
import staticmap

text
STATICMAP_AVAILABLE = True
except ImportError:
STATICMAP_AVAILABLE = False
logger.warning("staticmap not installed. Install with: pip install staticmap")

def decode_polyline(encoded: str, precision: int = 5) -> list[tuple[float, float]]:
"""
Decode a polyline string into a list of (longitude, latitude) tuples.

text
OpenRouteService uses encoded polylines (Google Polyline Algorithm)
to compress route coordinates. This function decodes them.

Args:
    encoded: Encoded polyline string
    precision: Coordinate precision (ORS uses 5)

Returns:
    list of (lon, lat) tuples
"""
coordinates = []
index = 0
lat = 0
lon = 0

while index < len(encoded):
    # Decode latitude
    shift = 0
    result = 0
    while True:
        b = ord(encoded[index]) - 63
        index += 1
        result |= (b & 0x1F) << shift
        shift += 5
        if b < 0x20:
            break

    dlat = ~(result >> 1) if result & 1 else result >> 1
    lat += dlat

    # Decode longitude
    shift = 0
    result = 0
    while True:
        b = ord(encoded[index]) - 63
        index += 1
        result |= (b & 0x1F) << shift
        shift += 5
        if b < 0x20:
            break

    dlon = ~(result >> 1) if result & 1 else result >> 1
    lon += dlon

    # Convert to decimal degrees
    coordinates.append(
        (
            lon / (10**precision),  # longitude first for GeoJSON
            lat / (10**precision),  # latitude second
        )
    )

return coordinates
class MapGenerator:
"""
Generate accurate route maps using OpenStreetMap tiles with full road geometry
from OpenRouteService.

text
Features:
- Full route geometry (all road points, not simplified)
- Encoded polyline decoding support
- Multi-segment routes with different colors
- Direction arrows showing route flow
- Rest and fuel stop markers along route
- Distance and duration info
"""

DEFAULT_WIDTH = 1200
DEFAULT_HEIGHT = 800

# Marker colors (RGB tuples for PIL, hex for staticmap)
MARKER_COLORS = {
    "start": {"rgb": (34, 139, 34), "hex": "#228B22"},  # Forest green
    "pickup": {"rgb": (30, 144, 255), "hex": "#1E90FF"},  # Dodger blue
    "dropoff": {"rgb": (220, 20, 60), "hex": "#DC143C"},  # Crimson
    "rest": {"rgb": (148, 0, 211), "hex": "#9400D3"},  # Purple
    "fuel": {"rgb": (255, 140, 0), "hex": "#FF8C00"},  # Dark orange
    "break": {"rgb": (255, 215, 0), "hex": "#FFD700"},  # Gold
}

# Route segment colors for multi-leg trips
SEGMENT_COLORS = [
    "#3388ff",  # Blue (primary)
    "#ff6b6b",  # Red
    "#4ecdc4",  # Teal
    "#45b7d1",  # Light blue
    "#96ceb4",  # Sage green
]

ROUTE_WIDTH = 4
MARKER_RADIUS = 14
SMALL_MARKER_RADIUS = 8

def generate_route_map(
    self,
    coordinates: list[dict[str, float]],
    segments: list[dict[str, Any]],
    geometry: Optional[dict[str, Any]] = None,
    width: int = DEFAULT_WIDTH,
    height: int = DEFAULT_HEIGHT,
    route_data: Optional[dict[str, Any]] = None,
) -> bytes:
    """
    Generate a route map showing the actual road route and stops.

    Args:
        coordinates: list of {lat, lon, name} dicts for waypoints
        segments: list of trip segments with types and locations
        geometry: OpenRouteService GeoJSON geometry with route coordinates
                 Format: {"type": "LineString", "coordinates": [[lon, lat], ...]}
                 Or encoded polyline string
        width: Image width in pixels
        height: Image height in pixels
        route_data: Full route data from ORS (for additional details)

    Returns:
        PNG image as bytes
    """
    # Decode geometry if it's an encoded polyline string
    decoded_geometry = self._process_geometry(geometry)

    if not STATICMAP_AVAILABLE:
        logger.warning("staticmap not available, using fallback")
        return self._generate_fallback_map(
            coordinates, segments, decoded_geometry, width, height
        )

    try:
        return self._generate_with_staticmap(
            coordinates, segments, decoded_geometry, width, height, route_data
        )
    except Exception as e:
        logger.error(f"Error generating map: {e}", exc_info=True)
        return self._generate_fallback_map(
            coordinates, segments, decoded_geometry, width, height
        )

def _process_geometry(
    self, geometry: Optional[dict[str, Any]]
) -> Optional[dict[str, Any]]:
    """
    Process geometry - decode if encoded polyline, otherwise return as-is.
    """
    if geometry is None:
        return None

    # If it's already a GeoJSON geometry with coordinates
    if isinstance(geometry, dict) and geometry.get("coordinates"):
        coords = geometry["coordinates"]
        # Validate coordinates format
        if coords and isinstance(coords[0], (list, tuple)) and len(coords[0]) >= 2:
            logger.info(f"Using GeoJSON geometry with {len(coords)} points")
            return geometry

    # If it's an encoded polyline string
    if isinstance(geometry, str):
        try:
            decoded = decode_polyline(geometry)
            logger.info(f"Decoded polyline with {len(decoded)} points")
            return {
                "type": "LineString",
                "coordinates": [[lon, lat] for lon, lat in decoded],
            }
        except Exception as e:
            logger.error(f"Failed to decode polyline: {e}")
            return None

    # Check if geometry contains encoded polyline
    if isinstance(geometry, dict):
        encoded = geometry.get("encoded") or geometry.get("polyline")
        if encoded and isinstance(encoded, str):
            try:
                decoded = decode_polyline(encoded)
                logger.info(f"Decoded embedded polyline with {len(decoded)} points")
                return {
                    "type": "LineString",
                    "coordinates": [[lon, lat] for lon, lat in decoded],
                }
            except Exception as e:
                logger.error(f"Failed to decode embedded polyline: {e}")

    return geometry

def _generate_with_staticmap(
    self,
    coordinates: list[dict[str, float]],
    segments: list[dict[str, Any]],
    geometry: Optional[dict[str, Any]],
    width: int,
    height: int,
    route_data: Optional[dict[str, Any]] = None,
) -> bytes:
    """Generate map using staticmap library with full route geometry."""

    # Create static map with OSM tiles
    m = staticmap.StaticMap(
        width,
        height,
        url_template="https://tile.openstreetmap.org/{z}/{x}/{y}.png",
        tile_size=256,
    )

    # Draw the route
    route_drawn = False
    route_points = 0

    if geometry and geometry.get("coordinates"):
        route_coords = geometry["coordinates"]
        route_points = len(route_coords)

        if route_points >= 2:
            # Convert to staticmap format: list of (lon, lat) tuples
            line_coords = [(coord[0], coord[1]) for coord in route_coords]

            # Draw route outline (darker, wider) for better visibility
            outline = staticmap.Line(
                line_coords,
                "#1a5276",  # Dark blue outline
                self.ROUTE_WIDTH + 2,
            )
            m.add_line(outline)

            # Draw main route line
            route_line = staticmap.Line(
                line_coords,
                self.SEGMENT_COLORS[0],
                self.ROUTE_WIDTH,
            )
            m.add_line(route_line)
            route_drawn = True

            logger.info(f"Drawing accurate route with {route_points} road points")

            # Add direction arrows along the route
            self._add_direction_markers(m, line_coords)

    # Fallback: straight lines between waypoints if no geometry
    if not route_drawn and len(coordinates) >= 2:
        logger.warning(
            "No route geometry, drawing straight lines between waypoints"
        )
        line_coords = [(c["lon"], c["lat"]) for c in coordinates]
        fallback_line = staticmap.Line(
            line_coords,
            "#999999",
            2,
        )
        m.add_line(fallback_line)

    # Extract all markers including intermediate stops
    markers = self._extract_all_markers(coordinates, segments, geometry)

    # Add markers - small ones first, then main waypoints on top
    for marker in sorted(markers, key=lambda m: m.get("priority", 0)):
        color = self.MARKER_COLORS.get(marker["type"], {}).get("hex", "#808080")
        radius = marker.get("radius", self.MARKER_RADIUS)

        # Add white outline for visibility
        outline_marker = staticmap.CircleMarker(
            (marker["lon"], marker["lat"]),
            "white",
            radius + 3,
        )
        m.add_marker(outline_marker)

        # Add colored marker
        circle = staticmap.CircleMarker(
            (marker["lon"], marker["lat"]),
            color,
            radius,
        )
        m.add_marker(circle)

    # Render the map
    try:
        image = m.render()
    except Exception as e:
        logger.error(f"Failed to render map: {e}")
        raise

    # Add overlays
    image = self._add_legend(image, markers, segments)
    image = self._add_route_info(image, coordinates, geometry, route_data)
    image = self._add_waypoint_labels(image, markers, m)

    # Convert to bytes
    buf = io.BytesIO()
    image.save(buf, format="PNG")
    buf.seek(0)

    logger.info(
        f"Generated route map: {route_points} points, {len(markers)} markers"
    )
    return buf.getvalue()

def _add_direction_markers(
    self,
    m: "staticmap.StaticMap",
    line_coords: list[tuple[float, float]],
    interval: int = 50,
) -> None:
    """
    Add small direction indicators along the route.

    Args:
        m: StaticMap instance
        line_coords: Route coordinates
        interval: Add marker every N points
    """
    if len(line_coords) < interval * 2:
        return

    # Add small markers at intervals to show direction
    for i in range(interval, len(line_coords) - interval, interval):
        coord = line_coords[i]

        # Small dot to indicate route direction
        dot = staticmap.CircleMarker(
            coord,
            "#ffffff",
            3,
        )
        m.add_marker(dot)

def _extract_all_markers(
    self,
    coordinates: list[dict[str, float]],
    segments: list[dict[str, Any]],
    geometry: Optional[dict[str, Any]],
) -> list[dict[str, Any]]:
    """
    Extract all markers including waypoints and intermediate stops.
    """
    markers = []

    # Main waypoints (higher priority, larger markers)
    for i, coord in enumerate(coordinates):
        if i == 0:
            marker_type = "start"
        elif i == len(coordinates) - 1:
            marker_type = "dropoff"
        else:
            marker_type = "pickup"

        markers.append(
            {
                "lat": coord["lat"],
                "lon": coord["lon"],
                "type": marker_type,
                "label": coord.get("name", f"Point {i + 1}"),
                "radius": self.MARKER_RADIUS,
                "priority": 10,  # High priority - render on top
            }
        )

    # Extract intermediate stops from segments
    # These need coordinates - estimate position along route if not provided
    route_coords = []
    if geometry and geometry.get("coordinates"):
        route_coords = geometry["coordinates"]

    total_route_points = len(route_coords)
    segment_index = 0

    for seg in segments:
        seg_type = seg.get("type", "")

        if seg_type in ["rest", "fuel", "break"]:
            # Try to get coordinates from segment
            seg_lat = seg.get("lat") or seg.get("latitude")
            seg_lon = seg.get("lon") or seg.get("longitude")

            if seg_lat and seg_lon:
                markers.append(
                    {
                        "lat": seg_lat,
                        "lon": seg_lon,
                        "type": seg_type,
                        "label": seg.get("location", seg_type.capitalize()),
                        "radius": self.SMALL_MARKER_RADIUS,
                        "priority": 5,
                    }
                )
            elif total_route_points > 0:
                # Estimate position along route based on segment order
                segment_index += 1
                # This is a rough estimate - place stop proportionally along route
                est_position = min(
                    int(total_route_points * segment_index / (len(segments) + 1)),
                    total_route_points - 1,
                )
                est_coord = route_coords[est_position]

                markers.append(
                    {
                        "lat": est_coord[1],
                        "lon": est_coord[0],
                        "type": seg_type,
                        "label": seg.get(
                            "location", f"{seg_type.capitalize()} Stop"
                        ),
                        "radius": self.SMALL_MARKER_RADIUS,
                        "priority": 5,
                        "estimated": True,
                    }
                )

    return markers

def _add_waypoint_labels(
    self,
    img: Image.Image,
    markers: list[dict[str, Any]],
    static_map: "staticmap.StaticMap",
) -> Image.Image:
    """
    Add text labels near waypoints.

    Note: staticmap doesn't expose coordinate-to-pixel conversion,
    so this is a simplified version that adds labels in corners.
    """
    draw = ImageDraw.Draw(img)
    font = self._load_font(11)

    # Add start/end labels in corners as reference
    main_markers = [m for m in markers if m.get("priority", 0) >= 10]

    if main_markers:
        # Start label (top-left area, below legend)
        start = next((m for m in main_markers if m["type"] == "start"), None)
        if start:
            label = f"▶ Start: {start['label'][:30]}"
            draw.text((20, 220), label, fill=(34, 139, 34), font=font)

        # End label
        end = next((m for m in main_markers if m["type"] == "dropoff"), None)
        if end:
            label = f"◼ End: {end['label'][:30]}"
            draw.text((20, 240), label, fill=(220, 20, 60), font=font)

        # Pickup label
        pickup = next((m for m in main_markers if m["type"] == "pickup"), None)
        if pickup:
            label = f"● Pickup: {pickup['label'][:30]}"
            draw.text((20, 260), label, fill=(30, 144, 255), font=font)

    return img

def _add_legend(
    self,
    img: Image.Image,
    markers: list[dict[str, Any]],
    segments: list[dict[str, Any]],
) -> Image.Image:
    """Add a legend showing marker types and route info."""
    draw = ImageDraw.Draw(img)
    font = self._load_font(13)
    small_font = self._load_font(11)

    # Legend position
    legend_x = img.width - 210
    legend_y = 20
    legend_width = 190

    # Count marker types
    type_counts = {}
    for marker in markers:
        t = marker["type"]
        type_counts[t] = type_counts.get(t, 0) + 1

    legend_height = 70 + len(type_counts) * 26

    # Background with shadow effect
    shadow_offset = 3
    draw.rectangle(
        [
            (legend_x + shadow_offset, legend_y + shadow_offset),
            (
                legend_x + legend_width + shadow_offset,
                legend_y + legend_height + shadow_offset,
            ),
        ],
        fill=(200, 200, 200),
    )
    draw.rectangle(
        [(legend_x, legend_y), (legend_x + legend_width, legend_y + legend_height)],
        fill=(255, 255, 255),
        outline=(100, 100, 100),
        width=1,
    )

    # Title
    draw.text(
        (legend_x + 10, legend_y + 10),
        "Route Legend",
        fill=(40, 40, 40),
        font=font,
    )

    # Separator line
    draw.line(
        [
            (legend_x + 10, legend_y + 32),
            (legend_x + legend_width - 10, legend_y + 32),
        ],
        fill=(200, 200, 200),
        width=1,
    )

    # Legend items
    y_offset = 42
    type_order = ["start", "pickup", "dropoff", "rest", "fuel", "break"]

    for marker_type in type_order:
        if marker_type not in type_counts:
            continue

        count = type_counts[marker_type]
        color = self.MARKER_COLORS.get(marker_type, {}).get("rgb", (128, 128, 128))

        # Color circle
        cx = legend_x + 20
        cy = legend_y + y_offset + 8
        r = 8

        # White outline
        draw.ellipse(
            [(cx - r - 1, cy - r - 1), (cx + r + 1, cy + r + 1)],
            fill=(255, 255, 255),
            outline=(150, 150, 150),
        )
        draw.ellipse([(cx - r, cy - r), (cx + r, cy + r)], fill=color)

        # Label
        label_map = {
            "start": "Start",
            "pickup": "Pickup",
            "dropoff": "Dropoff",
            "rest": "Rest Stop",
            "fuel": "Fuel Stop",
            "break": "Break",
        }
        label = f"{label_map.get(marker_type, marker_type)}: {count}"
        draw.text(
            (legend_x + 38, legend_y + y_offset),
            label,
            fill=(60, 60, 60),
            font=small_font,
        )
        y_offset += 26

    return img

def _add_route_info(
    self,
    img: Image.Image,
    coordinates: list[dict[str, float]],
    geometry: Optional[dict[str, Any]],
    route_data: Optional[dict[str, Any]] = None,
) -> Image.Image:
    """Add route information overlay with distance/duration if available."""
    draw = ImageDraw.Draw(img)
    font = self._load_font(11)

    # Info box at bottom-left
    info_x = 20
    info_y = img.height - 100

    info_lines = []

    # Route accuracy info
    if geometry and geometry.get("coordinates"):
        num_points = len(geometry["coordinates"])
        info_lines.append(f"Route accuracy: {num_points:,} points")
        info_lines.append("✓ Following actual roads")
    else:
        info_lines.append("⚠ Schematic view only")

    info_lines.append(f"Waypoints: {len(coordinates)}")

    # Add distance/duration if available in route_data
    if route_data:
        distance = route_data.get("total_distance") or route_data.get("distance")
        duration = route_data.get("total_duration") or route_data.get("duration")

        if distance:
            if isinstance(distance, (int, float)):
                info_lines.append(f"Distance: {distance:.1f} miles")

        if duration:
            if isinstance(duration, (int, float)):
                hours = int(duration)
                minutes = int((duration - hours) * 60)
                info_lines.append(f"Est. drive time: {hours}h {minutes}m")

    if info_lines:
        # Calculate box size
        line_height = 18
        box_height = len(info_lines) * line_height + 16
        box_width = 220

        # Background with shadow
        draw.rectangle(
            [
                (info_x + 2, info_y + 2),
                (info_x + box_width + 2, info_y + box_height + 2),
            ],
            fill=(200, 200, 200),
        )
        draw.rectangle(
            [(info_x, info_y), (info_x + box_width, info_y + box_height)],
            fill=(255, 255, 255),
            outline=(150, 150, 150),
        )

        # Draw text
        for i, text in enumerate(info_lines):
            y_pos = info_y + 8 + i * line_height

            # Use checkmark/warning colors
            if text.startswith("✓"):
                color = (34, 139, 34)  # Green
            elif text.startswith("⚠"):
                color = (200, 150, 0)  # Orange/yellow
            else:
                color = (60, 60, 60)

            draw.text((info_x + 10, y_pos), text, fill=color, font=font)

    return img

def _generate_fallback_map(
    self,
    coordinates: list[dict[str, float]],
    segments: list[dict[str, Any]],
    geometry: Optional[dict[str, Any]],
    width: int,
    height: int,
) -> bytes:
    """Generate a schematic map without external tile fetching."""

    img = Image.new("RGB", (width, height), color=(250, 250, 250))
    draw = ImageDraw.Draw(img)

    if not coordinates:
        return self._generate_placeholder_map(
            width, height, "No coordinates provided"
        )

    # Calculate bounds
    all_points = [(c["lon"], c["lat"]) for c in coordinates]

    if geometry and geometry.get("coordinates"):
        all_points.extend([(c[0], c[1]) for c in geometry["coordinates"]])

    if not all_points:
        return self._generate_placeholder_map(width, height, "No valid coordinates")

    lons = [p[0] for p in all_points]
    lats = [p[1] for p in all_points]

    min_lon, max_lon = min(lons), max(lons)
    min_lat, max_lat = min(lats), max(lats)

    # Add padding
    lon_padding = (max_lon - min_lon) * 0.12 or 1.0
    lat_padding = (max_lat - min_lat) * 0.12 or 1.0

    min_lon -= lon_padding
    max_lon += lon_padding
    min_lat -= lat_padding
    max_lat += lat_padding

    # Map area dimensions
    margin = 50
    legend_width = 230
    map_width = width - legend_width - margin * 2
    map_height = height - margin * 2
    map_x = margin
    map_y = margin

    # Draw map background with border
    draw.rectangle(
        [(map_x - 2, map_y - 2), (map_x + map_width + 2, map_y + map_height + 2)],
        fill=(200, 200, 200),
    )
    draw.rectangle(
        [(map_x, map_y), (map_x + map_width, map_y + map_height)],
        fill=(255, 255, 255),
    )

    # Draw grid
    self._draw_grid(
        draw,
        map_x,
        map_y,
        map_width,
        map_height,
        min_lon,
        max_lon,
        min_lat,
        max_lat,
    )

    # Coordinate conversion function
    def to_pixel(lon: float, lat: float) -> tuple[int, int]:
        x = map_x + int((lon - min_lon) / (max_lon - min_lon) * map_width)
        y = map_y + int((max_lat - lat) / (max_lat - min_lat) * map_height)
        return (x, y)

    # Draw route geometry
    if geometry and geometry.get("coordinates"):
        route_coords = geometry["coordinates"]
        if len(route_coords) >= 2:
            points = [to_pixel(c[0], c[1]) for c in route_coords]

            # Draw outline
            for i in range(len(points) - 1):
                draw.line([points[i], points[i + 1]], fill=(26, 82, 118), width=5)

            # Draw main line
            for i in range(len(points) - 1):
                draw.line([points[i], points[i + 1]], fill=(51, 136, 255), width=3)
    else:
        # Fallback: straight lines
        if len(coordinates) >= 2:
            points = [to_pixel(c["lon"], c["lat"]) for c in coordinates]
            for i in range(len(points) - 1):
                draw.line([points[i], points[i + 1]], fill=(180, 180, 180), width=2)

    # Draw markers
    markers = self._extract_all_markers(coordinates, segments, geometry)
    font = self._load_font(10)

    for marker in sorted(markers, key=lambda m: m.get("priority", 0)):
        x, y = to_pixel(marker["lon"], marker["lat"])
        color = self.MARKER_COLORS.get(marker["type"], {}).get(
            "rgb", (128, 128, 128)
        )
        r = marker.get("radius", self.MARKER_RADIUS)

        # White border
        draw.ellipse(
            [(x - r - 2, y - r - 2), (x + r + 2, y + r + 2)],
            fill=(255, 255, 255),
            outline=(100, 100, 100),
        )
        # Colored fill
        draw.ellipse([(x - r, y - r), (x + r, y + r)], fill=color)

        # Label for main markers
        if marker.get("priority", 0) >= 10:
            label = marker.get("label", "")[:20]
            if label:
                bbox = draw.textbbox((0, 0), label, font=font)
                text_width = bbox[2] - bbox[0]

                # Background for label
                label_x = x - text_width // 2
                label_y = y + r + 4
                draw.rectangle(
                    [
                        (label_x - 2, label_y - 1),
                        (label_x + text_width + 2, label_y + 12),
                    ],
                    fill=(255, 255, 255, 200),
                )
                draw.text((label_x, label_y), label, fill=(40, 40, 40), font=font)

    # Add legend
    img = self._add_legend(img, markers, segments)

    # Add title
    title_font = self._load_font(16)
    draw = ImageDraw.Draw(img)
    title = "Trip Route Map"
    if not geometry or not geometry.get("coordinates"):
        title += " (Schematic)"
    draw.text((map_x + 10, map_y + 10), title, fill=(40, 40, 40), font=title_font)

    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)

    return buf.getvalue()

def _draw_grid(
    self,
    draw: ImageDraw.ImageDraw,
    map_x: int,
    map_y: int,
    map_width: int,
    map_height: int,
    min_lon: float,
    max_lon: float,
    min_lat: float,
    max_lat: float,
) -> None:
    """Draw latitude/longitude grid lines."""
    grid_color = (240, 240, 240)
    text_color = (180, 180, 180)
    font = self._load_font(8)

    # Horizontal lines (latitude)
    num_lat_lines = 5
    for i in range(num_lat_lines + 1):
        y = map_y + int(i * map_height / num_lat_lines)
        draw.line([(map_x, y), (map_x + map_width, y)], fill=grid_color, width=1)

        lat = max_lat - (i / num_lat_lines) * (max_lat - min_lat)
        draw.text((map_x + 3, y + 2), f"{lat:.2f}°", fill=text_color, font=font)

    # Vertical lines (longitude)
    num_lon_lines = 6
    for i in range(num_lon_lines + 1):
        x = map_x + int(i * map_width / num_lon_lines)
        draw.line([(x, map_y), (x, map_y + map_height)], fill=grid_color, width=1)

        lon = min_lon + (i / num_lon_lines) * (max_lon - min_lon)
        draw.text(
            (x + 2, map_y + map_height - 12),
            f"{lon:.2f}°",
            fill=text_color,
            font=font,
        )

def _load_font(self, size: int) -> ImageFont.FreeTypeFont:
    """Load a TrueType font with fallback."""
    font_paths = [
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
        "/System/Library/Fonts/Helvetica.ttc",
        "C:\\Windows\\Fonts\\arial.ttf",
        "/usr/share/fonts/truetype/freefont/FreeSans.ttf",
    ]

    for path in font_paths:
        try:
            return ImageFont.truetype(path, size)
        except Exception:
            continue

    return ImageFont.load_default()

def _generate_placeholder_map(
    self,
    width: int,
    height: int,
    message: str = "Map Unavailable",
) -> bytes:
    """Generate a placeholder image with error message."""
    img = Image.new("RGB", (width, height), color=(245, 245, 245))
    draw = ImageDraw.Draw(img)

    font = self._load_font(20)

    bbox = draw.textbbox((0, 0), message, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]

    x = (width - text_width) // 2
    y = (height - text_height) // 2

    draw.text((x, y), message, fill=(150, 150, 150), font=font)

    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return buf.getvalue()
================================================
FILE: eld_logs/route_calculator/services/route_service.py
import logging
from typing import Any, Optional

import requests
from django.conf import settings

logger = logging.getLogger(name)

class RouteService:
"""Service for calculating routes using OpenRouteService API."""

text
BASE_URL = "https://api.openrouteservice.org"

def __init__(self) -> None:
    """Initialize RouteService with API key."""
    self.api_key = settings.OPENROUTESERVICE_API_KEY
    if not self.api_key:
        raise ValueError("OPENROUTESERVICE_API_KEY not configured in settings")

def geocode_location(self, location: str) -> Optional[dict[str, float]]:
    """
    Convert location string to coordinates using OpenRouteService geocoding.

    Args:
        location: Location name (e.g., "Dallas, TX")

    Returns:
        dictionary with lon, lat, and name or None if not found
    """
    try:
        url = f"{self.BASE_URL}/geocode/search"
        params = {"api_key": self.api_key, "text": location, "size": 1}
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()

        data = response.json()
        if not data.get("features"):
            logger.warning(f"No geocoding results for: {location}")
            return None

        coords = data["features"][0]["geometry"]["coordinates"]
        place_name = data["features"][0]["properties"].get("label", location)

        return {"lon": coords[0], "lat": coords[1], "name": place_name}
    except requests.exceptions.RequestException as e:
        logger.error(f"Geocoding request failed for '{location}': {e}")
        return None
    except (KeyError, IndexError) as e:
        logger.error(f"Geocoding response parsing failed for '{location}': {e}")
        return None
    except Exception as e:
        logger.error(f"Unexpected geocoding error for '{location}': {e}")
        return None

def get_route(self, coordinates: list[list[float]]) -> Optional[dict[str, Any]]:
    """
    Get route between coordinates using OpenRouteService directions API.

    Args:
        coordinates: list of [lon, lat] pairs

    Returns:
        Route data in GeoJSON format or None if calculation fails
    """
    try:
        url = f"{self.BASE_URL}/v2/directions/driving-hgv/geojson"
        headers = {
            "Authorization": self.api_key,
            "Content-Type": "application/json",
        }
        payload = {
            "coordinates": coordinates,
            "preference": "recommended",
            "units": "mi",
        }

        response = requests.post(url, json=payload, headers=headers, timeout=15)
        response.raise_for_status()

        return response.json()
    except requests.exceptions.RequestException as e:
        logger.error(f"Route calculation request failed: {e}")
        return None
    except Exception as e:
        logger.error(f"Unexpected route calculation error: {e}")
        return None

def get_route_legs(self, route: dict[str, Any]) -> list[dict[str, float]]:
    """
    Extract route legs from OpenRouteService response.

    Args:
        route: Route data from OpenRouteService

    Returns:
        list of route legs with distance (miles) and duration (hours)
    """
    legs: list[dict[str, float]] = []

    try:
        if "features" not in route or not route["features"]:
            logger.warning("No features in route response")
            return legs

        feature = route["features"][0]
        summary = feature.get("properties", {}).get("summary", {})

        # Convert meters to miles and seconds to hours
        distance_miles = summary.get("distance", 0) / 1609.34
        duration_hours = summary.get("duration", 0) / 3600.0

        legs.append(
            {
                "distance": round(distance_miles, 2),
                "duration": round(duration_hours, 2),
            }
        )

        logger.info(
            f"Extracted route leg: {distance_miles:.2f} miles, "
            f"{duration_hours:.2f} hours"
        )

    except (KeyError, TypeError) as e:
        logger.error(f"Error extracting route legs: {e}")

    return legs
================================================
FILE: eld_logs/route_calculator/services/test_log_generator.py
from log_generator import LogGenerator

log_data = {
"date": "04/09/2021",
"total_miles": 350,
"from_address": "Richmond, VA",
"to_address": "Newark, NJ",
"home_terminal_address": "Washington, D.C.",
"truck_number": "123, 20544",
"shipping_doc": "101601",
"events": [
{"start": 0, "end": 6, "status": "offDuty"},
{"start": 6, "end": 7.5, "status": "onDuty"},
{"start": 7.5, "end": 9, "status": "driving"},
{"start": 9, "end": 9.5, "status": "onDuty"},
{"start": 9.5, "end": 12, "status": "driving"},
{"start": 12, "end": 13, "status": "offDuty"},
{"start": 13, "end": 15, "status": "driving"},
{"start": 15, "end": 15.5, "status": "onDuty"},
{"start": 15.5, "end": 16, "status": "driving"},
{"start": 16, "end": 17.75, "status": "sleeper"},
{"start": 17.75, "end": 19, "status": "driving"},
{"start": 19, "end": 21, "status": "onDuty"},
{"start": 21, "end": 24, "status": "offDuty"},
],
"remarks": [
{"location": "Richmond, VA"},
{"location": "Fredericksburg, VA"},
{"location": "Baltimore, MD"},
{"location": "Philadelphia, PA"},
{"location": "Cherry Hill, NJ"},
{"location": "Newark, NJ"},
],
}

gen = LogGenerator()
img = gen.generate_log_image(
log_data,
1,
"John E. Doe",
"John Doe's Transportation",
"Washington, D.C.",
"Jane Doe", # Co-driver
)

with open("output_daily_log.png", "wb") as f:
f.write(img)

print("Generated output_daily_log.png")

thees more


Got it! I can see the core services now. Please share the remaining files - particularly any Docker/docker-compose files, and I'll provide the complete improved solution.

Key Issues Identified So Far
File	Issue	Priority
settings/base.py	SQLite only, no PostgreSQL	🔴 High
views.py	download_map is synchronous/blocking	🔴 High
map_generator.py	Long-running, no progress tracking	🔴 High
tasks.py	No progress updates during execution	🟡 Medium
models.py	Missing map generation status fields	🟡 Medium
route_service.py	No connection retry/timeout config	🟡 Medium
What I'll Provide Once You Share Remaining Files
1. PostgreSQL Support
Database configuration with connection pooling
Migration for new fields
Environment variable setup
2. Async Map Generation with Progress
python
# Preview of the approach:
class TripCalculation(models.Model):
    # New fields for map generation tracking
    map_status = models.CharField(...)  # pending, generating, completed, failed
    map_progress = models.IntegerField(default=0)  # 0-100
    map_file = models.FileField(...)  # Store generated map
3. Real-time Frontend Communication
Option A: WebSocket (Django Channels)
Option B: Server-Sent Events (SSE)
Option C: Enhanced polling with progress
Please share:

Any Docker/docker-compose files
Any remaining files (if any)
Your preference for frontend communication (WebSocket, SSE, or polling)?
This will help me provide a complete, production-ready solution!

Claude Opus 4.5
================================================
FILE: eld_logs/route_calculator/services/test_map_generator.py
#!/usr/bin/env python
"""
Test script for MapGenerator with actual route geometry.

Run with: python test_map_generator.py
"""

import io
import logging
import os
import sys
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple

logging.basicConfig(
level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(name)

try:
from PIL import Image, ImageDraw, ImageFont
except ImportError:
print("Missing Pillow. Install with: pip install Pillow")
sys.exit(1)

try:
import staticmap

text
STATICMAP_AVAILABLE = True
print("✓ staticmap library available")
except ImportError:
STATICMAP_AVAILABLE = False
print("⚠ staticmap not installed (pip install staticmap)")

Simulated OpenRouteService geometry (actual road coordinates)
This represents a route following real roads, not straight lines
SAMPLE_GEOMETRY_NYC_TO_PHILLY = {
"type": "LineString",
"coordinates": [
# NYC
[-74.006, 40.7128],
[-74.0055, 40.7135],
[-74.003, 40.718],
# Through NJ
[-74.05, 40.735],
[-74.1, 40.75],
[-74.15, 40.72],
[-74.2, 40.7],
[-74.3, 40.68],
[-74.4, 40.65],
[-74.5, 40.6],
[-74.6, 40.55],
[-74.7, 40.5],
[-74.8, 40.45],
[-74.9, 40.4],
# Into PA
[-75.0, 40.35],
[-75.05, 40.3],
[-75.1, 40.25],
[-75.12, 40.2],
[-75.14, 40.1],
[-75.16, 40.05],
# Philadelphia
[-75.1652, 39.9526],
],
}

SAMPLE_GEOMETRY_CROSS_COUNTRY = {
"type": "LineString",
"coordinates": [
# NYC
[-74.006, 40.7128],
[-74.5, 40.6],
[-75.0, 40.4],
[-75.5, 40.3],
[-76.0, 40.2],
[-77.0, 40.0],
[-78.0, 39.8],
[-79.0, 39.6],
[-80.0, 39.5],
[-81.0, 39.4],
[-82.0, 39.5],
[-83.0, 39.7],
[-84.0, 39.9],
[-85.0, 40.2],
[-86.0, 40.5],
[-87.0, 41.0],
# Chicago
[-87.6298, 41.8781],
[-88.0, 41.5],
[-90.0, 41.0],
[-92.0, 40.5],
[-95.0, 39.5],
[-98.0, 38.5],
[-100.0, 37.5],
[-103.0, 36.5],
[-106.0, 35.5],
[-109.0, 35.0],
[-112.0, 34.5],
[-115.0, 34.2],
# LA
[-118.2437, 34.0522],
],
}

class MapGenerator:
"""MapGenerator with route geometry support - copy for testing."""

text
DEFAULT_WIDTH = 1200
DEFAULT_HEIGHT = 800

MARKER_COLORS = {
    "start": {"rgb": (34, 139, 34), "hex": "#228B22"},
    "pickup": {"rgb": (30, 144, 255), "hex": "#1E90FF"},
    "dropoff": {"rgb": (220, 20, 60), "hex": "#DC143C"},
    "rest": {"rgb": (148, 0, 211), "hex": "#9400D3"},
    "fuel": {"rgb": (255, 140, 0), "hex": "#FF8C00"},
}

ROUTE_COLOR = "#3388ff"
ROUTE_WIDTH = 4
MARKER_RADIUS = 12

def generate_route_map(
    self,
    coordinates: List[Dict[str, float]],
    segments: List[Dict[str, Any]],
    geometry: Optional[Dict[str, Any]] = None,
    width: int = DEFAULT_WIDTH,
    height: int = DEFAULT_HEIGHT,
) -> bytes:
    if STATICMAP_AVAILABLE:
        try:
            return self._generate_with_staticmap(
                coordinates, segments, geometry, width, height
            )
        except Exception as e:
            logger.error(f"staticmap error: {e}", exc_info=True)

    return self._generate_fallback_map(
        coordinates, segments, geometry, width, height
    )

def _generate_with_staticmap(
    self,
    coordinates: List[Dict[str, float]],
    segments: List[Dict[str, Any]],
    geometry: Optional[Dict[str, Any]],
    width: int,
    height: int,
) -> bytes:
    m = staticmap.StaticMap(
        width,
        height,
        url_template="https://tile.openstreetmap.org/{z}/{x}/{y}.png",
        tile_size=256,
    )

    # Draw actual route geometry
    if geometry and geometry.get("coordinates"):
        route_coords = geometry["coordinates"]
        if len(route_coords) >= 2:
            line_coords = [(c[0], c[1]) for c in route_coords]
            route_line = staticmap.Line(
                line_coords,
                self.ROUTE_COLOR,
                self.ROUTE_WIDTH,
            )
            m.add_line(route_line)
            logger.info(f"Drawing route with {len(route_coords)} points")

    # Add markers
    markers = self._extract_markers(coordinates, segments)
    for marker in markers:
        color = self.MARKER_COLORS.get(marker["type"], {}).get("hex", "#808080")
        circle = staticmap.CircleMarker(
            (marker["lon"], marker["lat"]),
            color,
            self.MARKER_RADIUS,
        )
        m.add_marker(circle)

    image = m.render()
    image = self._add_legend(image, markers, segments)

    buf = io.BytesIO()
    image.save(buf, format="PNG")
    buf.seek(0)
    return buf.getvalue()

def _generate_fallback_map(
    self,
    coordinates: List[Dict[str, float]],
    segments: List[Dict[str, Any]],
    geometry: Optional[Dict[str, Any]],
    width: int,
    height: int,
) -> bytes:
    img = Image.new("RGB", (width, height), color=(245, 245, 245))
    draw = ImageDraw.Draw(img)

    if not coordinates:
        return self._generate_placeholder_map(width, height)

    # Calculate bounds
    all_points = [(c["lon"], c["lat"]) for c in coordinates]
    if geometry and geometry.get("coordinates"):
        all_points.extend([(c[0], c[1]) for c in geometry["coordinates"]])

    lons = [p[0] for p in all_points]
    lats = [p[1] for p in all_points]

    min_lon, max_lon = min(lons), max(lons)
    min_lat, max_lat = min(lats), max(lats)

    lon_pad = (max_lon - min_lon) * 0.1 or 1.0
    lat_pad = (max_lat - min_lat) * 0.1 or 1.0
    min_lon -= lon_pad
    max_lon += lon_pad
    min_lat -= lat_pad
    max_lat += lat_pad

    margin = 40
    legend_w = 220
    map_w = width - legend_w - margin * 2
    map_h = height - margin * 2
    map_x, map_y = margin, margin

    draw.rectangle(
        [(map_x, map_y), (map_x + map_w, map_y + map_h)],
        fill=(255, 255, 255),
        outline=(200, 200, 200),
        width=2,
    )

    def to_px(lon, lat):
        x = map_x + int((lon - min_lon) / (max_lon - min_lon) * map_w)
        y = map_y + int((max_lat - lat) / (max_lat - min_lat) * map_h)
        return x, y

    # Draw route
    if geometry and geometry.get("coordinates"):
        pts = [to_px(c[0], c[1]) for c in geometry["coordinates"]]
        for i in range(len(pts) - 1):
            draw.line([pts[i], pts[i + 1]], fill=(51, 136, 255), width=3)

    # Draw markers
    markers = self._extract_markers(coordinates, segments)
    font = self._load_font(10)

    for marker in markers:
        x, y = to_px(marker["lon"], marker["lat"])
        color = self.MARKER_COLORS.get(marker["type"], {}).get(
            "rgb", (128, 128, 128)
        )
        r = self.MARKER_RADIUS
        draw.ellipse(
            [(x - r - 2, y - r - 2), (x + r + 2, y + r + 2)], fill=(255, 255, 255)
        )
        draw.ellipse([(x - r, y - r), (x + r, y + r)], fill=color)

        label = marker.get("label", "")[:20]
        if label:
            bbox = draw.textbbox((0, 0), label, font=font)
            tw = bbox[2] - bbox[0]
            draw.text((x - tw // 2, y + r + 4), label, fill=(60, 60, 60), font=font)

    img = self._add_legend(img, markers, segments)

    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return buf.getvalue()

def _extract_markers(self, coordinates, segments):
    markers = []
    for i, coord in enumerate(coordinates):
        if i == 0:
            t = "start"
        elif i == len(coordinates) - 1:
            t = "dropoff"
        else:
            t = "pickup"
        markers.append(
            {
                "lat": coord["lat"],
                "lon": coord["lon"],
                "type": t,
                "label": coord.get("name", f"Point {i+1}"),
            }
        )
    return markers

def _add_legend(self, img, markers, segments):
    draw = ImageDraw.Draw(img)
    font = self._load_font(12)

    legend_x = img.width - 200
    legend_y = 20

    types = {}
    for m in markers:
        types[m["type"]] = types.get(m["type"], 0) + 1

    h = 50 + len(types) * 25
    draw.rectangle(
        [(legend_x, legend_y), (legend_x + 180, legend_y + h)],
        fill=(255, 255, 255),
        outline=(180, 180, 180),
    )
    draw.text(
        (legend_x + 10, legend_y + 10), "Legend", fill=(40, 40, 40), font=font
    )

    y = 38
    for t in ["start", "pickup", "dropoff", "rest", "fuel"]:
        if t not in types:
            continue
        color = self.MARKER_COLORS.get(t, {}).get("rgb", (128, 128, 128))
        cx, cy = legend_x + 18, legend_y + y + 6
        draw.ellipse([(cx - 6, cy - 6), (cx + 6, cy + 6)], fill=color)
        draw.text(
            (legend_x + 32, legend_y + y),
            f"{t.capitalize()}: {types[t]}",
            fill=(60, 60, 60),
            font=font,
        )
        y += 25

    return img

def _load_font(self, size):
    paths = [
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/System/Library/Fonts/Helvetica.ttc",
        "C:\\Windows\\Fonts\\arial.ttf",
    ]
    for p in paths:
        try:
            return ImageFont.truetype(p, size)
        except:
            continue
    return ImageFont.load_default()

def _generate_placeholder_map(self, width, height):
    img = Image.new("RGB", (width, height), color=(240, 240, 240))
    draw = ImageDraw.Draw(img)
    font = self._load_font(20)
    text = "Map Unavailable"
    bbox = draw.textbbox((0, 0), text, font=font)
    x = (width - (bbox[2] - bbox[0])) // 2
    y = (height - (bbox[3] - bbox[1])) // 2
    draw.text((x, y), text, fill=(120, 120, 120), font=font)
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return buf.getvalue()
============================================================
TESTS
============================================================
def test_route_with_geometry():
"""Test map with actual route geometry (following roads)."""
print("\n" + "=" * 60)
print("TEST 1: Route with Actual Road Geometry (NYC -> Philly)")
print("=" * 60)

text
gen = MapGenerator()

coordinates = [
    {"lat": 40.7128, "lon": -74.006, "name": "New York, NY"},
    {"lat": 39.9526, "lon": -75.1652, "name": "Philadelphia, PA"},
]

segments = [
    {"type": "start", "location": "New York, NY"},
    {"type": "drive", "distance": 95},
    {"type": "dropoff", "location": "Philadelphia, PA"},
]

try:
    image_bytes = gen.generate_route_map(
        coordinates=coordinates,
        segments=segments,
        geometry=SAMPLE_GEOMETRY_NYC_TO_PHILLY,  # Actual road path!
    )

    out = "test_map_with_road_geometry.png"
    with open(out, "wb") as f:
        f.write(image_bytes)

    size = os.path.getsize(out)
    print(f"✓ Generated: {out} ({size:,} bytes)")
    print(
        f"✓ Route follows {len(SAMPLE_GEOMETRY_NYC_TO_PHILLY['coordinates'])} road points"
    )

    img = Image.open(out)
    print(f"✓ Image: {img.width}x{img.height}")
    return True
except Exception as e:
    print(f"✗ FAILED: {e}")
    import traceback

    traceback.print_exc()
    return False
def test_cross_country_route():
"""Test cross-country route with geometry."""
print("\n" + "=" * 60)
print("TEST 2: Cross-Country Route (NYC -> Chicago -> LA)")
print("=" * 60)

text
gen = MapGenerator()

coordinates = [
    {"lat": 40.7128, "lon": -74.006, "name": "New York, NY"},
    {"lat": 41.8781, "lon": -87.6298, "name": "Chicago, IL"},
    {"lat": 34.0522, "lon": -118.2437, "name": "Los Angeles, CA"},
]

segments = [
    {"type": "start", "location": "New York, NY"},
    {"type": "drive", "distance": 790},
    {"type": "pickup", "location": "Chicago, IL"},
    {"type": "rest", "location": "Iowa"},
    {"type": "drive", "distance": 2015},
    {"type": "fuel", "location": "Arizona"},
    {"type": "dropoff", "location": "Los Angeles, CA"},
]

try:
    image_bytes = gen.generate_route_map(
        coordinates=coordinates,
        segments=segments,
        geometry=SAMPLE_GEOMETRY_CROSS_COUNTRY,
    )

    out = "test_map_cross_country.png"
    with open(out, "wb") as f:
        f.write(image_bytes)

    print(f"✓ Generated: {out} ({os.path.getsize(out):,} bytes)")
    return True
except Exception as e:
    print(f"✗ FAILED: {e}")
    return False
def test_no_geometry_fallback():
"""Test fallback when no geometry provided."""
print("\n" + "=" * 60)
print("TEST 3: Fallback - No Geometry (Straight Lines)")
print("=" * 60)

text
gen = MapGenerator()

coordinates = [
    {"lat": 38.9072, "lon": -77.0369, "name": "Washington, DC"},
    {"lat": 39.2904, "lon": -76.6122, "name": "Baltimore, MD"},
    {"lat": 39.9526, "lon": -75.1652, "name": "Philadelphia, PA"},
]

segments = [
    {"type": "start"},
    {"type": "pickup"},
    {"type": "dropoff"},
]

try:
    image_bytes = gen.generate_route_map(
        coordinates=coordinates,
        segments=segments,
        geometry=None,  # No geometry - should draw straight lines
    )

    out = "test_map_no_geometry.png"
    with open(out, "wb") as f:
        f.write(image_bytes)

    print(f"✓ Generated fallback: {out} ({os.path.getsize(out):,} bytes)")
    print("  (Should show straight lines, not road paths)")
    return True
except Exception as e:
    print(f"✗ FAILED: {e}")
    return False
def test_staticmap_tiles():
"""Test that staticmap fetches real OSM tiles."""
print("\n" + "=" * 60)
print("TEST 4: OSM Tile Fetching (if staticmap available)")
print("=" * 60)

text
if not STATICMAP_AVAILABLE:
    print("⚠ Skipped - staticmap not installed")
    return True

gen = MapGenerator()

coordinates = [
    {"lat": 47.6062, "lon": -122.3321, "name": "Seattle, WA"},
    {"lat": 45.5152, "lon": -122.6784, "name": "Portland, OR"},
]

# Simple geometry along I-5
geometry = {
    "type": "LineString",
    "coordinates": [
        [-122.3321, 47.6062],
        [-122.4, 47.4],
        [-122.5, 47.0],
        [-122.6, 46.5],
        [-122.65, 46.0],
        [-122.68, 45.8],
        [-122.6784, 45.5152],
    ],
}

try:
    image_bytes = gen.generate_route_map(
        coordinates=coordinates,
        segments=[],
        geometry=geometry,
    )

    out = "test_map_osm_tiles.png"
    with open(out, "wb") as f:
        f.write(image_bytes)

    size = os.path.getsize(out)
    print(f"✓ Generated with OSM tiles: {out} ({size:,} bytes)")

    # Real tile maps are usually larger
    if size > 50000:
        print("✓ File size indicates real map tiles were fetched")
    else:
        print("⚠ Small file - may be fallback rendering")

    return True
except Exception as e:
    print(f"✗ FAILED: {e}")
    return False
def run_all_tests():
print("\n" + "#" * 60)
print("# MapGenerator Test Suite - Route Geometry Support")
print(f"# {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print(f"# staticmap available: {STATICMAP_AVAILABLE}")
print("#" * 60)

text
tests = [
    ("Route with Road Geometry", test_route_with_geometry),
    ("Cross-Country Route", test_cross_country_route),
    ("No Geometry Fallback", test_no_geometry_fallback),
    ("OSM Tile Fetching", test_staticmap_tiles),
]

results = []
for name, func in tests:
    try:
        results.append((name, func()))
    except Exception as e:
        print(f"✗ {name} crashed: {e}")
        results.append((name, False))

print("\n" + "=" * 60)
print("SUMMARY")
print("=" * 60)

passed = sum(1 for _, r in results if r)
for name, r in results:
    print(f"  {'✓' if r else '✗'} {name}")

print(f"\n  {passed}/{len(results)} passed")

files = [
    f for f in os.listdir(".") if f.startswith("test_map_") and f.endswith(".png")
]
if files:
    print("\n  Generated files:")
    for f in sorted(files):
        print(f"    📁 {f} ({os.path.getsize(f):,} bytes)")

return passed == len(results)
if name == "main":
success = run_all_tests()
sys.exit(0 if success else 1)

================================================
FILE: eld_logs/route_calculator/services/tests/test_hos_calculator.py
from ..services.hos_calculator import HOSCalculator

def test_hos_calculation_basic_trip():
hos = HOSCalculator(cycle_used=10)

text
segments, summary = hos.calculate_trip_segments(
    total_distance=300,
    start_location="Dallas, TX",
    pickup_location="Houston, TX",
    dropoff_location="Austin, TX",
    route_legs=[{"distance": 300, "duration": 6}],
)

assert segments
assert any(s["type"] == "drive" for s in segments)

total_drive_time = sum(s["duration"] for s in segments if s["type"] == "drive")

assert total_drive_time <= hos.MAX_DRIVING_TIME
================================================
FILE: eld_logs/route_calculator/services/tests/test_log_generator.py
import io

import pytest
from PIL import Image

from ..services.log_generator import LogGenerator

@pytest.fixture
def sample_log_data():
return {
"date": "04/09/2021",
"total_miles": 350,
"events": [
{"start": 0, "end": 6, "status": "offDuty"},
{"start": 6, "end": 8, "status": "driving"},
{"start": 8, "end": 9, "status": "onDuty"},
{"start": 9, "end": 24, "status": "offDuty"},
],
"remarks": [{"location": "Richmond, VA"}],
}

@pytest.fixture
def full_log_data():
"""Log data with all fields populated."""
return {
"date": "04/09/2021",
"total_miles": 350,
"events": [
{"start": 0, "end": 6, "status": "offDuty"},
{"start": 6, "end": 7.5, "status": "onDuty"},
{"start": 7.5, "end": 9, "status": "driving"},
{"start": 9, "end": 9.5, "status": "onDuty"},
{"start": 9.5, "end": 12, "status": "driving"},
{"start": 12, "end": 13, "status": "offDuty"},
{"start": 13, "end": 15, "status": "driving"},
{"start": 15, "end": 15.5, "status": "onDuty"},
{"start": 15.5, "end": 16, "status": "driving"},
{"start": 16, "end": 17.75, "status": "sleeper"},
{"start": 17.75, "end": 19, "status": "driving"},
{"start": 19, "end": 21, "status": "onDuty"},
{"start": 21, "end": 24, "status": "offDuty"},
],
"remarks": [
{"location": "Richmond, VA"},
{"location": "Fredericksburg, VA"},
{"location": "Baltimore, MD"},
{"location": "Philadelphia, PA"},
{"location": "Cherry Hill, NJ"},
{"location": "Newark, NJ"},
],
}

def test_generate_log_image_returns_png(sample_log_data):
"""Test that basic log generation returns a valid PNG image."""
generator = LogGenerator()

text
image_bytes = generator.generate_log_image(
    log_data=sample_log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Test Carrier",
    main_office="Washington, D.C.",
    co_driver="",
    from_address="",
    to_address="",
    home_terminal_address="",
    truck_number="",
    shipping_doc="",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_all_parameters(full_log_data):
"""Test log generation with all parameters populated."""
generator = LogGenerator()

text
image_bytes = generator.generate_log_image(
    log_data=full_log_data,
    day_number=1,
    driver_name="John E. Doe",
    carrier_name="John Doe's Transportation",
    main_office="Washington, D.C.",
    co_driver="Jane Doe",
    from_address="Richmond, VA",
    to_address="Newark, NJ",
    home_terminal_address="Washington, D.C.",
    truck_number="123, 20544",
    shipping_doc="101601",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_default_parameters(sample_log_data):
"""Test log generation using default parameter values."""
generator = LogGenerator()

text
image_bytes = generator.generate_log_image(
    log_data=sample_log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Test Carrier",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_fallback_to_log_data():
"""Test that log_data values are used as fallback when parameters are empty."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 500,
    "from_address": "Atlanta, GA",
    "to_address": "Miami, FL",
    "home_terminal_address": "Atlanta, GA",
    "truck_number": "TRUCK-999",
    "shipping_doc": "SHIP-12345",
    "events": [
        {"start": 0, "end": 8, "status": "offDuty"},
        {"start": 8, "end": 16, "status": "driving"},
        {"start": 16, "end": 24, "status": "offDuty"},
    ],
    "remarks": [],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=1,
    driver_name="Test Driver",
    carrier_name="Test Carrier",
    main_office="Atlanta, GA",
    co_driver="",
    from_address="",  # Should fallback to log_data
    to_address="",  # Should fallback to log_data
    home_terminal_address="",  # Should fallback to log_data
    truck_number="",  # Should fallback to log_data
    shipping_doc="",  # Should fallback to log_data
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_empty_events():
"""Test log generation with no events."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 0,
    "events": [],
    "remarks": [],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Test Carrier",
    main_office="Washington, D.C.",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_multiple_remarks(full_log_data):
"""Test log generation with multiple remarks."""
generator = LogGenerator()

text
image_bytes = generator.generate_log_image(
    log_data=full_log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Test Carrier",
    main_office="Washington, D.C.",
    from_address="Richmond, VA",
    to_address="Newark, NJ",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_empty_remarks():
"""Test log generation with empty remarks list."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 200,
    "events": [
        {"start": 0, "end": 12, "status": "offDuty"},
        {"start": 12, "end": 20, "status": "driving"},
        {"start": 20, "end": 24, "status": "offDuty"},
    ],
    "remarks": [],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Test Carrier",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_remarks_missing_location():
"""Test log generation with remarks that have no location."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 200,
    "events": [
        {"start": 0, "end": 12, "status": "offDuty"},
        {"start": 12, "end": 20, "status": "driving"},
        {"start": 20, "end": 24, "status": "offDuty"},
    ],
    "remarks": [
        {"location": "Richmond, VA"},
        {},  # Missing location
        {"location": ""},  # Empty location
        {"location": "Baltimore, MD"},
    ],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Test Carrier",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_all_duty_statuses():
"""Test log generation with all four duty statuses."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 300,
    "events": [
        {"start": 0, "end": 6, "status": "offDuty"},
        {"start": 6, "end": 8, "status": "sleeper"},
        {"start": 8, "end": 16, "status": "driving"},
        {"start": 16, "end": 18, "status": "onDuty"},
        {"start": 18, "end": 24, "status": "offDuty"},
    ],
    "remarks": [{"location": "Test Location"}],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Test Carrier",
    main_office="Washington, D.C.",
    truck_number="T-1234",
    shipping_doc="DOC-5678",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_fractional_hours():
"""Test log generation with fractional hour values."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 275,
    "events": [
        {"start": 0, "end": 6.5, "status": "offDuty"},
        {"start": 6.5, "end": 7.25, "status": "onDuty"},
        {"start": 7.25, "end": 11.75, "status": "driving"},
        {"start": 11.75, "end": 12.5, "status": "offDuty"},
        {"start": 12.5, "end": 17.33, "status": "driving"},
        {"start": 17.33, "end": 24, "status": "offDuty"},
    ],
    "remarks": [],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=2,
    driver_name="Jane Smith",
    carrier_name="Smith Trucking",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_with_co_driver():
"""Test log generation with co-driver specified."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 600,
    "events": [
        {"start": 0, "end": 10, "status": "sleeper"},
        {"start": 10, "end": 20, "status": "driving"},
        {"start": 20, "end": 24, "status": "sleeper"},
    ],
    "remarks": [{"location": "Truck Stop, OH"}],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Team Trucking Inc.",
    main_office="Columbus, OH",
    co_driver="Jane Doe",
    from_address="New York, NY",
    to_address="Los Angeles, CA",
    home_terminal_address="Columbus, OH",
    truck_number="TEAM-001",
    shipping_doc="TEAM-SHIP-999",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_invalid_status_ignored():
"""Test that invalid duty statuses are ignored."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 100,
    "events": [
        {"start": 0, "end": 8, "status": "offDuty"},
        {"start": 8, "end": 12, "status": "invalidStatus"},  # Invalid
        {"start": 12, "end": 16, "status": "driving"},
        {"start": 16, "end": 24, "status": "offDuty"},
    ],
    "remarks": [],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=1,
    driver_name="John Doe",
    carrier_name="Test Carrier",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_generate_log_image_boundary_hours():
"""Test log generation with events at boundary hours (0 and 24)."""
generator = LogGenerator()

text
log_data = {
    "date": "04/09/2021",
    "total_miles": 400,
    "events": [
        {"start": 0, "end": 24, "status": "driving"},
    ],
    "remarks": [],
}

image_bytes = generator.generate_log_image(
    log_data=log_data,
    day_number=1,
    driver_name="Marathon Driver",
    carrier_name="Test Carrier",
)

assert isinstance(image_bytes, (bytes, bytearray))
img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_log_generator_initialization():
"""Test that LogGenerator initializes correctly."""
generator = LogGenerator()

text
assert generator.fonts is not None
assert "small" in generator.fonts
assert "medium" in generator.fonts
assert "x-small" in generator.fonts
================================================
FILE: eld_logs/route_calculator/services/tests/test_map_generator.py
import io
from unittest.mock import Mock, patch

import pytest
from PIL import Image

from ..services.map_generator import MapGenerator

@pytest.fixture
def sample_coordinates():
return [
{"lat": 32.7767, "lon": -96.7970, "name": "Dallas, TX"},
{"lat": 29.7604, "lon": -95.3698, "name": "Houston, TX"},
{"lat": 33.7490, "lon": -84.3880, "name": "Atlanta, GA"},
]

@pytest.fixture
def sample_segments():
return [
{"type": "start", "location": "Dallas, TX"},
{"type": "pickup", "location": "Houston, TX"},
{"type": "drive", "location": "En route"},
{"type": "rest", "location": "Rest Area"},
{"type": "fuel", "location": "Fuel Station"},
{"type": "dropoff", "location": "Atlanta, GA"},
]

@pytest.fixture
def fake_map_image_bytes():
img = Image.new("RGB", (1200, 800), "white")
buf = io.BytesIO()
img.save(buf, format="PNG")
return buf.getvalue()

@patch("route_calculator.services.map_generator.requests.get")
def test_generate_route_map_success(
mock_get, sample_coordinates, sample_segments, fake_map_image_bytes
):
mock_get.return_value = Mock(
status_code=200,
content=fake_map_image_bytes,
)
mock_get.return_value.raise_for_status = lambda: None

text
generator = MapGenerator()
image_bytes = generator.generate_route_map(
    coordinates=sample_coordinates,
    segments=sample_segments,
)

img = Image.open(io.BytesIO(image_bytes))
assert img.format == "PNG"
def test_extract_markers_assigns_types(sample_coordinates):
generator = MapGenerator()
markers = generator._extract_markers(sample_coordinates, [])

text
assert markers[0]["type"] == "start"
assert markers[1]["type"] == "pickup"
assert markers[-1]["type"] == "dropoff"
================================================
FILE: eld_logs/route_calculator/services/tests/test_route_service.py
from unittest.mock import patch

import pytest

from ..services.route_service import RouteService

@pytest.mark.django_db
@patch("route_calculator.services.route_service.requests.get")
def test_geocode_location_success(mock_get, settings):
settings.OPENROUTESERVICE_API_KEY = "fake-key"

text
mock_get.return_value.json.return_value = {
    "features": [
        {
            "geometry": {"coordinates": [-96.8, 32.7]},
            "properties": {"label": "Dallas, TX"},
        }
    ]
}
mock_get.return_value.raise_for_status = lambda: None

service = RouteService()
result = service.geocode_location("Dallas, TX")

assert result["lat"] == 32.7
assert result["lon"] == -96.8
================================================
FILE: eld_logs/route_calculator/tests/test_tasks.py
from unittest.mock import MagicMock, patch

import pytest

from ..models import TripCalculation
from ..tasks import calculate_trip_task

@pytest.fixture
def trip(db):
"""Create a pending trip calculation."""
return TripCalculation.objects.create(
current_location="Dallas, TX",
pickup_location="Houston, TX",
dropoff_location="Atlanta, GA",
current_cycle_used=10,
status=TripCalculation.JobStatus.PENDING,
)

-------------------------------------------------
SUCCESS CASE
-------------------------------------------------
@pytest.mark.django_db
@patch("route_calculator.tasks.RouteService")
@patch("route_calculator.tasks.HOSCalculator")
def test_calculate_trip_task_success(
mock_hos_cls,
mock_route_cls,
trip,
):
"""Task completes successfully and saves results."""

text
# ---- Mock RouteService ----
mock_route = MagicMock()
mock_route.geocode_location.side_effect = [
    {"lat": 32.7, "lon": -96.8, "name": "Dallas, TX"},
    {"lat": 29.7, "lon": -95.3, "name": "Houston, TX"},
    {"lat": 33.7, "lon": -84.3, "name": "Atlanta, GA"},
]
mock_route.get_route.return_value = {
    "features": [{"geometry": {"type": "LineString", "coordinates": []}}]
}
mock_route.get_route_legs.return_value = [{"distance": 800.0, "duration": 15.0}]
mock_route_cls.return_value = mock_route

# ---- Mock HOSCalculator ----
mock_hos = MagicMock()
mock_hos.calculate_trip_segments.return_value = (
    [
        {"type": "drive", "duration": 10.0, "distance": 550},
        {"type": "rest", "duration": 10.0, "distance": 0.0},
    ],
    [{"day": 1}],
)
mock_hos_cls.return_value = mock_hos

# ---- Execute task ----
result = calculate_trip_task(trip.id)

# ---- Assertions ----
trip.refresh_from_db()

assert result == trip.id
assert trip.status == TripCalculation.JobStatus.COMPLETED
assert trip.total_distance == 800.0
assert trip.total_driving_time == 10.0
assert trip.route_data is not None
assert trip.logs_data is not None
-------------------------------------------------
TRIP NOT FOUND
-------------------------------------------------
@pytest.mark.django_db
def test_calculate_trip_task_trip_not_found():
"""Returns None if trip does not exist."""
result = calculate_trip_task(999999)
assert result is None

-------------------------------------------------
GEOCODING FAILURE
-------------------------------------------------
@pytest.mark.django_db
@patch("route_calculator.tasks.RouteService")
def test_calculate_trip_task_geocode_failure(
mock_route_cls,
trip,
):
"""Task fails if geocoding fails."""
mock_route = MagicMock()
mock_route.geocode_location.return_value = None
mock_route_cls.return_value = mock_route

text
with pytest.raises(Exception):
    calculate_trip_task(trip.id)

trip.refresh_from_db()
assert trip.status == TripCalculation.JobStatus.FAILED
assert trip.error_message
-------------------------------------------------
RETRY BEHAVIOR
-------------------------------------------------
@pytest.mark.django_db
@patch("route_calculator.tasks.calculate_trip_task.retry")
@patch("route_calculator.tasks.RouteService")
def test_calculate_trip_task_retry_on_exception(
mock_route_cls,
mock_retry,
trip,
):
"""Celery retry is triggered on exception."""
mock_route = MagicMock()
mock_route.geocode_location.side_effect = Exception("Boom")
mock_route_cls.return_value = mock_route

text
with pytest.raises(Exception):
    calculate_trip_task(trip.id)

assert mock_retry.called
okay lets work on what I asked


Comprehensive Backend Improvements
Now I have the complete picture. Let me provide a comprehensive solution addressing:

PostgreSQL Support
Async Map Generation with Progress Tracking
Real-time Frontend Communication
Code Quality Improvements
1. PostgreSQL Support
Updated Settings
python
# eld_logs/eld_logs/settings/base.py

"""
Django settings for eld_logs project.
"""

from pathlib import Path
from decouple import Csv, config

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY: str = config(
    "SECRET_KEY",
    default="django-insecure-6*^%+(^j&eyng6v-(=7xeabs)%cl7+z9((o+6med7w-v&4cms7",
)

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG: bool = config("DEBUG", default=True, cast=bool)

ALLOWED_HOSTS: list[str] = config(
    "ALLOWED_HOSTS", default="localhost,127.0.0.1", cast=Csv()
)

# Application definition
INSTALLED_APPS = [
    "daphne",  # For ASGI/WebSocket support
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # Third party apps
    "rest_framework",
    "corsheaders",
    "drf_spectacular",
    "channels",  # WebSocket support
    "django_celery_results",  # Store Celery results in DB
    # Local apps
    "route_calculator",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "eld_logs.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "eld_logs.wsgi.application"
ASGI_APPLICATION = "eld_logs.asgi.application"

# DATABASE_ENGINE: str = config("DATABASE_ENGINE", default="postgresql")

# if DATABASE_ENGINE == "postgresql":
#     DATABASES = {
#         "default": {
#             "ENGINE": "django.db.backends.postgresql",
#             "NAME": config("DATABASE_NAME", default="eld_db"),
#             "USER": config("DATABASE_USERNAME", default="eld_user"),
#             "PASSWORD": config("DATABASE_PASSWORD", default="eld_password"),
#             "HOST": config("DATABASE_HOST", default="localhost"),
#             "PORT": config("DATABASE_PORT", default="5432"),
#             # Connection pooling and optimization
#             "CONN_MAX_AGE": config("DATABASE_CONN_MAX_AGE", default=60, cast=int),
#             "CONN_HEALTH_CHECKS": True,
#             "OPTIONS": {
#                 "connect_timeout": 10,
#                 "options": "-c statement_timeout=30000",  # 30 second query timeout
#             },
#         }
#     }
# else:
#     # Fallback to SQLite for development
#     DATABASES = {
#         "default": {
#             "ENGINE": "django.db.backends.sqlite3",
#             "NAME": BASE_DIR / "db.sqlite3",
#         }
#     }


# Password validation
# https://docs.djangoproject.com/en/6.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/6.0/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/6.0/howto/static-files/

STATIC_URL: str = "static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

# Media files
MEDIA_URL: str = "media/"
MEDIA_ROOT = BASE_DIR / "media"

# Default primary key field type
DEFAULT_AUTO_FIELD: str = "django.db.models.BigAutoField"

# REST Framework
REST_FRAMEWORK = {
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 100,
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
    ],
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}

# CORS Settings
CORS_ALLOWED_ORIGINS: list[str] = config(
    "CORS_ALLOWED_ORIGINS",
    default="http://localhost:3000,http://localhost:5173",
    cast=Csv(),
)
CORS_ALLOW_CREDENTIALS: bool = True

# Redis Configuration
REDIS_URL: str = config("REDIS_URL", default="redis://localhost:6379/0")

# Celery Configuration
CELERY_BROKER_URL: str = REDIS_URL
CELERY_RESULT_BACKEND: str = "django-db"  # Store results in PostgreSQL
CELERY_CACHE_BACKEND: str = "django-cache"
CELERY_ACCEPT_CONTENT: list[str] = ["json"]
CELERY_TASK_SERIALIZER: str = "json"
CELERY_RESULT_SERIALIZER: str = "json"
CELERY_TIMEZONE: str = "UTC"
CELERY_TASK_TRACK_STARTED: bool = True
CELERY_TASK_TIME_LIMIT: int = 30 * 60  # 30 minutes
CELERY_RESULT_EXTENDED: bool = True  # Store task args and kwargs

# Task routing
CELERY_TASK_ROUTES = {
    "route_calculator.tasks.generate_map_task": {"queue": "maps"},
    "route_calculator.tasks.calculate_trip_task": {"queue": "default"},
}

# Channels Configuration
CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": [REDIS_URL],
            "capacity": 1500,
            "expiry": 10,
        },
    },
}

# OpenRouteService API Key
OPENROUTESERVICE_API_KEY: str = config("OPENROUTESERVICE_API_KEY", default="")

# DRF Spectacular Settings
SPECTACULAR_SETTINGS = {
    "TITLE": "ELD Logs API",
    "DESCRIPTION": "API for route calculation, FMCSA HOS compliance, ELD logs, and route maps.",
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": False,
    "COMPONENT_SPLIT_REQUEST": True,
    "SCHEMA_PATH_PREFIX": "/api",
}

TEMPLATE_FILENAME = "blank-paper-log.png"
